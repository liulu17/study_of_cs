## 标识符
llvm有两种标识符：全局（函数，全局变量）和局部.全局（类型，寄存器名）用@前缀，局部用%前缀。特别的，有三种类型的标识符
1. 命名的值，例如%foo，@DivisionByZero
2. 匿名的值，例如%1，@2，%44
3. 常量

llvm要求使用%和@前缀的原因有两
1. 不会和llvm保留字冲突，llvm保留字不用%或者@
2. 编译器可以为匿名的标识符分配临时变量，而不会和符号表冲突

以下是三种示例代码，将整数变量 %x 乘以 8
简单方式
```llvm
%result = mul i32 %X, 8
```

```llvm
%result = shl i32 %X, 3
```
硬核方式
```llvm
%0 = add i32 %X, %X           ; yields i32:%0
%1 = add i32 %0, %0           ; yields i32:%1
%result = add i32 %1, %1
```
最后一种方式阐明了llvm几个重要的词法特征
1. 评论使用;符号
2. 当计算的结果没赋予给一个命名的变量，则会创建一个匿名的变量
3. 匿名变量在数字上是连续的，从0开始。注意基本块和匿名函数参数包块在内。例如，如果进入基本块没有赋予一个名称，所有函数参数都命名的，就会从0开始
   
## 模块结构
LLVM程序由多个模块组成，每个模块是输入程序的转换单元。每个模块包含函数，全局变量，符号表条目。模块可以使用LLVM链接器链接，链接器合并函数，全局变量，符号表，解析前向声明，这是一个"Hello world"模块的示例
```llvm
; Declare the string constant as a global constant.
@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"

; External declaration of the puts function
declare i32 @puts(ptr nocapture) nounwind

; Definition of main function
define i32 @main() {
  ; Call puts function to write out the string to stdout.
  call i32 @puts(ptr @.str)
  ret i32 0
}

; Named metadata
!0 = !{i32 42, null, !"string"}
!foo = !{!0}
```

该模块由一个全局变量@.str、全局函数@puts、全局函数@main组成。和命名的元数据foo组成
通常，全局变量和函数都是由一个指针表示，这个例子中是一个指向字符数组的指针和一个函数指针。这些全局变量有如下**链接类型**


## 链接类型
所有全局变量和函数有如下链接类型
- privete
  只能由当前模块使用
- internal
  和private差不多。只不过呈现为一个本地符号。对应了C中的static
- available_externally

。。。。。
- external_weak
  这个语法是ELF目标文件模块中的，这个符号直到链接前是弱符号。如果没有被链接，符号成为null而不是一个未定义的引用
- external
  如果上面的链接属性都没被使用，则默认为external。这个属性使得该变量全局可见。意味着它参与链接，且可以被用来解析外部符号引用

**全局函数或者变量的声明必须是external或者external_weak**

## 调用约束
LLVM函数，call指令、invokes都有一个可选的调用约束。调用方和被调用方都必须遵循该约束，否则程序UB，LLVM支持一下调用约束
- "ccc" -c调用约束(默认)
  这个约束支持可变参数的函数调用，并且函数声明和定义不一致是可以接受的
- "fastcc" -快速调用约定 
  试图使用快速函数调用，例如使用寄存器存储。这个约束不支持可变参数的函数调用，并且函数声明和定义必须一致。约束允许目使用任何技巧对于特定的目标产生快速代码，而不用和特定的ABI一致。
- "coldcc" - 冷酷的调用约束
- "cc 10" - 特定于haskell
- "cc 11" - 特定于高性能erlang
- "webkit_jscc" -特定于Webkit javascript
- "anyregcc" -代码补丁的动态调用约束
- "preserve_mostcc" -
  此调用约定试图使调用方中的代码尽可能不受干扰。这个约定在传递参数和返回值的方式上与 C 调用约定的行为相同，但是它使用了一组不同的调用方/被调用方保存的寄存器。这减轻了在调用方中调用之前和之后保存和恢复一个大寄存器集的负担。如果参数是在被调用方保存的寄存器中传递的，那么它们将由被调用方在整个调用过程中保留。这不适用于被调用方保存的寄存器中返回值。
- "cxx_fast_tlscc" 
- "tailcc" -尾部调用约定
  这个调用约定确保在尾部位置的调用总是被尾部调用优化。这个调用约定等效于 fastcc，除了一个额外的保证，即只要有可能就会生成尾调用。只有在使用这个、 fastcc、 GHC 或 HiPE 约定时，才能优化尾调用。此调用约定不支持 varargs，并要求所有调用的原型与函数定义的原型完全匹配。
- "swiftcc" -特定于swift的约定
- "swifttailcc" -特定于swift的约定
- "cfguard_checkcc" 
- "cc <n>" -数字化的约束
  任何调用约定都可以通过数字指定，从而允许使用特定于目标的调用约定。特定于目标的调用约定从64开始。

可以根据需要添加/定义更多的调用约定，以支持 Pascal 约定或任何其他众所周知的独立于目标的约定。

## 可见性方式
所有全局变量和函数有如下可见性
- "default" -默认方式
  对于使用 ELF 对象文件格式的目标，默认可见性意味着声明对其他模块是可见的，并且在共享库中，意味着可以重写声明的实体。在 Darwin 上，默认可见性意味着声明对其他模块是可见的。在 XCOFF，默认可见性意味着不会设置显式可见性位，符号是否对其他模块可见(即"导出")主要取决于提供给链接器的导出列表。默认可见性对应于语言中的"外部链接"。
- "hidden" -隐藏方式
  具有隐藏可见性的对象的两个声明如果位于同一个共享对象中，则引用同一个对象。通常，隐藏可见性表明该符号不会被放置到动态符号表中，因此没有其他模块(可执行或共享库)可以直接引用它。
- "protected" -保护风格
  在 ELF 上，受保护的可见性指示符号将放置在动态符号表中，但是定义模块中的引用将绑定到本地符号。也就是说，该符号不能被另一个模块重写

## DLL 存储类型
所有全局变量和函数有如下DLL 存储类型
- dllimport
- dllexport
  具有internal或者private链接性的符号不能有DLL 存储类型

## 线程局部存储模型
变量可以定义为 thread _ local，这意味着它不会被线程共享(每个线程将有一个独立的变量副本)。并非所有目标都支持线程局部变量。可选地，可以指定 TLS 模型:
- localdynamic
  只在当前共享库中使用的变量
- initialexec
  不会被动态加载的变量
- localexec
  可执行文件中定义并使用的变量

如果没有显示定义模型，使用"通用动态"模型
这些模型对应于 ELF TLS 模型; 有关在何种情况下可以使用不同模型的更多信息，请参见针对线程本地存储的 ELF 处理。如果指定的模型不受支持，或者可以做出更好的模型选择，目标可以选择不同的 TLS 模型。
模型也可以在别名中指定，但它只管理如何访问别名。它在别名中不会有任何作用。
对于不支持 ELF TLS 模型的连接器的平台，可以使用-feumated-TLS 标志生成与 GCC 兼容的仿真 TLS 码

## 运行时抢占
全局变量、函数和别名可能有一个可选的运行时抢占说明符。如果没有显式地给出抢占说明符，则假定符号为 dso_preemptable。
- dso_preemptable
指示在运行时可以用来自链接单元外部的符号替换函数或变量。
- dso_local
编译器可能假设标记为 dso_local 的函数或变量将解析为同一链接单元内的符号。即使定义不在此编译单元中，也会生成直接访问。

## 结构类型
LLVM同时允许标识化类型，或者结构类型的字面量。结构类型的字面量是结构上唯一的，但是标识化类型从不是唯一的。opaque结构化的类型可以用来前向申明类型
标识化的结构示例
```
%mytype = type {%mytype*,i32}
```
在LLVM3.0版本中，标识化的结构也是唯一的，目前，只有结构类型的字面量是唯一的

## 非整数指针类型
注意：非整数指针类型还在进展中，当前只是实验性的
LLVM IR 允许前端通过datalayout string将特定地址空间中的指针表示为"非整数"。非整数指针类型表示不指定位大小表示形式的指针; 也就是说，整数表示形式可能与目标相关或不稳定(不以固定整数支持)。
Inttoptr 和 ptrtoint 指令与整数(即普通)指针具有相同的语义，因为它们将整数与相应的指针类型进行转换，但是还有其他的含义需要注意。由于非整数指针的位表示可能不稳定，同一操作数的两个相同强制转换可能返回相同的值，也可能不返回相同的值。换句话说，向非整数类型转换或从非整数类型转换取决于环境状态以实现定义的方式。
如果前端希望在强制转换后观察特定的值，则生成的 IR 必须以实现定义的方式与底层环境保护。(实际上，这种操作往往需要非线性例程。)
从优化器的角度来看，非整型类型的 inttoptr 和 ptrtoint 类似于整型类型的 inttoptr 和 ptrtoint，但有一个关键的例外: 优化器通常不会插入这种强制转换的新的动态发生。如果插入新的强制转换，优化器需要确保 a)所有可能的值都是有效的，或 b)插入适当的隔离。由于适当的隔离是实现定义的，因此优化器不能执行后者。前者具有挑战性，因为许多常见的预期属性(如 ptrtoint (v)-ptrtoint (v) = = 0)不适用于非整数类型

## 全局变量
全局变量定义一块编译时分配的内存；全局变量必须在定义时初始化；全局变量在其他转换单元可以被声明，但是不用初始化。
全局变量可选的指定的链接类型

全局变量定义和声明可以有可选的显式节，可选的显式的对齐方式。如果变量声明的显式节信息和对齐信息与定义之间不匹配，则UB
一个变量可以被定义为一个全局常量，这表明变量的内容永远不会被修改(允许更好的优化，允许全局数据被放置在可执行文件的只读部分，等等)。注意，需要运行时初始化的变量不能标记为常量，因为该变量存储在一个存储区中。

LLVM 显式地允许将全局变量的声明标记为常量，即使全局变量的最终定义不是常量。这个功能可以用来稍微优化程序，但是需要语言定义来保证基于"常量"的优化对于不包含定义的翻译单元是有效的。

作为 SSA 值，全局变量定义范围内的指针值(即它们支配程序中的所有基本块)。全局变量总是定义一个指向其"内容"类型的指针，因为它们描述内存的一个区域，并且 LLVM 中的所有内存对象都是通过指针访问的。
全局变量可以用 unname_addr 标记，表示地址不重要，只有内容重要。如果标记为这样的常量具有相同的初始值设定项，则它们可以与其他常量合并。请注意，具有有效地址的常量可以与unname_addr 常量合并，其结果是具有有效地址的常量。

如果给定 local_unname_addr 属性，则已知该地址在模块中不重要。

可以将全局变量声明为驻留在特定于目标的编号地址空间中。对于支持它们的目标，地址空间可能会影响执行优化的方式和/或使用哪些目标指令来访问变量。默认地址空间为零。地址空间限定符必须位于任何其他属性之前。

LLVM 允许为全局变量指定一个显式节。如果目标支持它，它将向指定的节发出全局值。此外，如果目标具有必要的支持，则可以将全局放置在一个 comdat 中。

外部声明可以具有指定的显式节。在 LLVM IR，利用这些资料的目标会保留部分资料。将节信息附加到外部声明是断言其定义位于指定的节中。如果定义位于不同的部分，则行为是未定义的。

默认情况下，全局初始化器通过假设在模块中定义的全局变量不会在全局初始化器启动之前从它们的初始值进行修改来进行优化。即使对于可能从模块外部访问的变量也是如此，包括那些具有外部链接或出现在@llvm 中的变量。使用或 dllexported 的变量。这个假设可以通过使用外部初始化标记变量来抑制。

可以为全局指定显式对齐，全局对齐的幂必须为2。如果不存在，或者如果对齐设置为零，则目标将全局对齐设置为它感觉方便的任何值。如果指定了显式对齐方式，则强制全局变量对齐方式必须与该对齐方式完全一致。如果全局变量有一个分配的节，则不允许目标和优化器过度对齐全局变量。在这种情况下，额外的对齐是可以观察到的: 例如，代码可以假设全局变量在它们的部分中密集排列，并尝试将它们作为数组进行迭代，对齐填充会破坏这种迭代。最大对齐方式为1 < < 32。

对于全局变量声明，以及可能在链接时被替换的定义(linkonce, weak, extern_weak and common linkage types) ，LLVM 不会假设变量的分配大小，除非它们可能不会重叠。全局变量声明或可替换定义的对齐方式不得大于它所解析的定义的对齐方式。

全局变量还可以有一个 DLL 存储类、一个可选的运行时抢占说明符、一个可选的全局属性和一个可选的附加元数据列表。

变量和别名可以具有线程本地存储模型

可伸缩向量不能是全局变量或数组成员，因为它们在编译时的大小是未知的。在结构中允许使用它们来方便内部函数返回多个值。包含可伸缩向量的结构不能在加载、存储、分配或 GEP 中使用。

语法如下：
```llvm
@<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]
                   [DLLStorageClass] [ThreadLocal]
                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]
                   [ExternallyInitialized]
                   <global | constant> <Type> [<InitializerConstant>]
                   [, section "name"] [, partition "name"]
                   [, comdat [($name)]] [, align <Alignment>]
                   [, no_sanitize_address] [, no_sanitize_hwaddress]
                   [, sanitize_address_dyninit] [, sanitize_memtag]
                   (, !name !N)*
```
例如,下面定义了一个全局变量，变量定义在数字化的地址空间中，有一个初始化器，节，对齐
```llvm
@G = addrspace(5) constant float 1.0, section "foo", align 4
```

下面只是定义了一个全局变量
```llvm
@G = external global i32
```
下面定义了一个线程局部全局变量，TLS模型为initialexec
```llvm
@G = thread_local(initialexec) global i32 0, align 4
```

## 函数
LLVM 函数定义包括define关键字、可选的链接类型、可选的运行时抢占指定符、可选的可见性样式、可选的 DLL 存储类、可选的调用约定、可选的 unname_addr 属性、返回类型、返回类型的可选参数属性、函数名称,参数列表(可能为空)、可选函数属性、可选地址空间、可选部分、可选分区、可选对齐、可选指数、可选垃圾收集器名称、可选前缀、可选序言、可选个性、可选附加元数据列表、开头花括号、基本块列表和结尾花括号。
语法:
```llvm
define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       <ResultType> @<FunctionName> ([argument list])
       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]
       [section "name"] [partition "name"] [comdat [($name)]] [align N]
       [gc] [prefix Constant] [prologue Constant] [personality Constant]
       (!name !N)* { ... }
```
参数列表使用逗号分隔，每个参数形式如下:
```llvm
<type> [parameter Attrs] [name]
```

LLVM声明包括declare关键字，可选的链接类型，可选的可见性样式，可选的 DLL 存储类，可选的调用约定，可选的 unname_addr 属性，可选地址空间，返回类型，返回类型的可选参数属性，函数名，可能得参数空列表，可选的对齐，可选的垃圾回收名字，可选的前缀
语法：
```llvm
declare [linkage] [visibility] [DLLStorageClass]
        [cconv] [ret attrs]
        <ResultType> @<FunctionName> ([argument list])
        [(unnamed_addr|local_unnamed_addr)] [align N] [gc]
        [prefix Constant] [prologue Constant]
```

函数定义包含一个基本块列表，形成函数的 CFG (控制流程图)。每个基本块可以选择从一个标签开始(给基本块一个符号表条目) ，包含一个指令列表，并以一个结束符指令(如分支或函数返回)结束。如果未提供显式标签名称，则使用与未命名临时项相同的计数器中的下一个值为块分配隐式编号标签(参见上文)。例如，如果一个函数条目块没有显式的标签，它将被分配标签"% 0"，那么该块中第一个未命名的临时标签将是"% 1"，等等。如果显式指定了数值标签，则它必须与将隐式使用的数值标签匹配。

函数的第一个基本块在两个方面是特殊的: 它在函数的入口处立即执行，不允许有前面的基本块(即不能有任何分支到函数的入口块)。因为该块不能有任何前置，所以它也不能有任何 PHI 节点。

LLVM 允许为函数指定显式节。如果目标支持它，它将向指定的节发出函数。此外，该函数可以放置在 COMDAT 中。

可以为函数指定显式对齐方式。如果不存在，或者如果对齐设置为零，那么函数的对齐将由目标设置为它感觉方便的任何值。如果指定了显式对齐方式，则函数必须至少具有对应的对齐方式。所有对齐必须是2的幂。

如果给定了 unname_addr 属性，则已知地址不重要，并且可以合并两个相同的函数。

如果给定 local_unname_addr 属性，则已知该地址在模块中不重要。

如果没有给出明确的地址空间，那么它将默认为 datalayout 字符串中的程序地址空间。


## 别名
别名与函数或变量不同，它不创建任何新数据。它们只是现有位置的新符号和元数据。

别名具有一个名称和一个别名，该别名或者是一个全局值，或者是一个常量表达式。

别名可以具有可选的链接类型、可选的运行时抢占说明符、可选的可见性样式、可选的 DLL 存储类和可选的 tls 模型。

句法:
```llvm
@<Name> = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias <AliaseeTy>, <AliaseeTy>* @<Aliasee>
          [, partition "name"]
```

链接属性必须是private, internal, linkonce, weak, linkonce_odr, weak_odr, external, available_externally.之一。注意，有些系统链接器可能无法正确处理删除别名的弱符号。


不是 unname_addr 的别名保证具有与别名表达式相同的地址。unname_addr 只能保证指向相同的内容。

如果给定 local_unname_addr 属性，则已知该地址在模块中不重要。
由于别名只是第二个名称，因此应用了一些限制，其中一些限制只能在生成目标文件时检查:
- 定义别名的表达式在汇编时必须是可计算的。因为它只是一个名称，所以不能使用重新定位。
- 表达式中的任何别名都不能为weak，因为中间别名被重写的可能性，所以不能在对象文件中表示。
- 如果别名具有available_externally的链接属性，那么别名必须是available_externally全局值; 否则别名可以是表达式，但是表达式中的不能声明全局值，因为这需要重新定位，而这是不可能的。
- 如果在链接时或运行时别名或被别名的名称可能被模块外的符号替换，则任何优化都不能用别名替换别名，因为行为可能不同。别名可以用作名称，保证指向当前模块中的内容。


## IFuncs
IFuncs 与别名一样，不创建任何新数据或 func。它们只是动态链接器在运行时通过调用解析器函数解析的新符号。

IFuncs 有一个名称和一个解析器，该解析器是由动态链接器调用的函数，它返回与该名称关联的另一个函数的地址。

IFunc 可能有一个可选的链接类型和一个可选的可见性样式。
句法:
```llvm
@<Name> = [Linkage] [PreemptionSpecifier] [Visibility] ifunc <IFuncTy>, <ResolverTy>* @<Resolver>
          [, partition "name"]
```

## Comdats
COMDAT IR 提供对目标文件 COMDAT/节组功能的访问，这些功能表示相互关联的节。

Comdats 有一个表示 COMDAT 键的名称和一个选择类型，用于提供关于链接器如何在两个不同的对象文件中使用相同的键删除 Comdats 的输入。指针必须作为一个单位包括或省略。允许丢弃整个 Comdat，但不允许丢弃子集。

一个全局对象最多只能是一个坐标的成员。别名放置在其别名计算到的 COMDAT 中(如果有的话)。
语法：

```llvm
$<Name> = comdat SelectionKind
```
//todo

## 命名的元数据
命名的元数据是元数据的集合，元数据节点（不是元数据字符串）是命名的元数据唯一有效的操作数
1. 命名的元数据由字符串表示，该字符串有个元数据前缀。元数据名称不能有引号。"\xx"类型的逃逸符号是有效的
   
语法：
```llvm
; Some unnamed metadata nodes, which are referenced by the named metadata.
!0 = !{!"zero"}
!1 = !{!"one"}
!2 = !{!"two"}
; A named metadata.
!name = !{!0, !1, !2}
```

## 参数属性
函数返回值和参数都有一系列相关的属性。参数属性用来与额外的返回值或参数信息通信。
参数属性跟随在参数类型后面，是关键字。
示例：
```llvm
declare i32 @printf(ptr noalias nocapture, ...)
declare i32 @atoi(i8 zeroext)
declare signext i8 @returns_signed_char()
```

注意任何返回值的属性都跟随在函数参数列表的最后面
目前支持一下参数属性：
- [] todo

## 垃圾回收策略名
每个函数能指定垃圾回收策略名
```llvm
define void @f() gc "name" { ... }
```
- [] todo

## 前缀数据
前缀数据是与函数关联的数据，代码生成器将在函数的入口点之前立即发出这些数据。这个特性的目的是允许前端将特定语言的运行时元数据与特定函数关联起来，并通过函数指针提供，同时仍然允许调用函数指针。

为了访问给定函数的数据，程序可以将函数指针转换为指向常量类型和解引用索引 -1的指针。这意味着 IR 符号指向的位置刚刚超过前缀数据的末尾。例如，以一个带有单个i32前缀数据的函数为例,
```llvm
define void @f() prefix i32 123 { ... }
```
前缀数据可以如下方式引用
```llvm
%a = getelementptr inbounds i32, ptr @f, i32 -1
%b = load i32, ptr %a
```

前缀数据布局就像它是一个某个类型的全局变量的初始化器。函数的放置方式使得前缀数据的开头对齐。这意味着如果前缀数据的大小不是对齐大小的倍数，则函数的入口点将不会对齐。如果需要对函数的入口点进行对齐，则必须向前缀数据添加填充。

函数可以有前缀数据，但是没有主体。这个链接的语义类似于可用的外部链接，因为数据可以由优化器使用，但是不会在对象目标中发出。


## 序言数据
序言数据允许任意的代码可以被插入到函数体的前面，这可用于启用函数热修补和检测。

为了维护普通函数调用的语义，序言数据必须具有特定的格式。具体来说，它必须以一系列字节开始，这些字节解码为一系列机器指令，对模块的目标有效，这些机器指令将控制转移到序言数据之后的点，而不执行任何其他可见的操作。这允许内联函数和其他passes对函数定义语义的推理，而不需要推理序言数据。显然，这使得序言数据的格式高度依赖于目标。
- [] not understand

一个简单的列子，x86架构的序言数据i8 144 对应个nop指令
```llvm
define void @f() prologue i8 144 { ... }
```
一般来说，序言数据可以通过编码跳过元数据的相对分支指令来形成，就像在 x86 _ 64体系结构的有效序言数据示例中一样，其中前两个字节进行了编码 jmp .+10
```llvm
%0 = type <{ i8, i8, ptr }>

define void @f() prologue %0 <{ i8 235, i8 8, ptr @md}> { ... }
```

函数可能有序言数据，但没有主体。这个链接的语义类似于available_externally链接属性，因为数据可以由优化器使用，但是不会在目标文件中发出。


## Personality 函数
函数可以通过Personality 函数属性指定异常处理

## 属性组
属性组是由 IR 中的对象引用的属性组。它们对于保持.Ll 文件可读很重要，因为许多函数将使用相同的属性集。

属性组是模块级对象。要使用属性组，对象引用属性组的 ID (例如 # 37)。一个对象可以引用多个属性组。在这种情况下，将合并来自不同组的属性。

下面是一个函数的属性组示例，该函数应该始终内联，堆栈对齐方式为4，并且不应该使用 SSE 指令
```llvm
; Target-independent attributes:
attributes #0 = { alwaysinline alignstack=4 }

; Target-dependent attributes:
attributes #1 = { "no-sse" }

; Function @f has attributes: alwaysinline, alignstack=4, and "no-sse".
define void @f() #0 #1 { ... }
```

## 函数属性
函数属性设置为了传递有关函数的附加信息。函数属性被认为是**函数的一部分**，而不是**函数类型**的一部分，因此具有不同函数属性的函数可以具有相同的函数类型。
函数属性是遵循指定类型的简单关键字。如果需要多个属性，则它们是空间分隔的。例如:
```llvm
define void @f() noinline { ... }
define void @f() alwaysinline { ... }
define void @f() alwaysinline optsize { ... }
define void @f() optsize { ... }
```
具体属性如下
- [] todolist

## 调用站点属性
除了函数属性之外，还支持以下调用站点属性:
- [] todolist

## 全局属性
可以通过设置属性来传递有关全局变量的其他信息。与函数属性不同，全局变量上的属性分组为单个属性组。
- no_sanitize_address
- no_sanitize_hwaddress
- sanitize_memtag
- sanitize_address_dyninit

## 参数数捆绑
操作数捆绑是标记的 SSA 值集，可以与某些 LLVM 指令相关联(call s 和 invoke s)。在某种程度上，它们类似于元数据，但是删除它们是不正确的，并且会改变程序语义
语法：
```llvm
operand bundle set ::= '[' operand bundle (, operand bundle )* ']'
operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'
bundle operand ::= SSA value
tag ::= string constant
```
- [] todo

## 模块级内联汇编
模块可以包含"模块级别的内联汇编"块，它对应于 GCC 的"文件范围内联汇编"块。这些块在内部由 LLVM 连接，并被视为一个单独的单元，但是可以在 .ll 文件中分离。语法非常简单:
```llvm
module asm "inline asm code goes here"
module asm "more can go here"
```
字符串可以通过转义非打印字符来包含任何字符。使用的转义序列只是"\ xx"，其中"xx"是该数字的两位十六进制代码。

注意，汇编字符串必须可由 LLVM 的集成汇编程序解析(除非禁用它) ，即使在发出.s文件

## 数据布局
模块可以指定target特定的数据布局，表名数据在内存中的布局。语法如下：
```llvm
target datalayout = "layout specification"
```
数据布局规范包含一系列规范，由'-'符号分割，每个规范以字母开头，字母之后可能包含其他信息，以定义数据布局的某些方面。接受的规格如下:
- E 大端形式
- e 小端
- S<size> 指定以位为单位的堆栈的自然对齐方式。为了避免动态堆栈重新排列，堆栈变量的排列提升仅限于自然堆栈排列。堆栈对齐方式必须是8位的倍数。如果省略，自然堆栈对齐默认为"未指定"，这不会阻止任何对齐提升。
- P\<address space> 指定程序内存的地址空间。哈佛体系结构可以使用它来指定 LLVM 应该将函数之类的东西放入什么空间。如果省略，程序内存空间默认为默认地址空间为0，这相当于一个冯·诺伊曼结构，代码和数据位于同一空间。
- G\<address spqce> 指定全局变量的地址空间。如果省略，全局变量内存空间默认为默认地址空间为0。注意：没有地址空间的变量声明总是在地址空间0中创建，这个属性只影响在创建没有额外上下文信息的全局变量时使用的默认值(例如在 LLVM 传递中)。
- A\<address space> 指定通过alloca创建的对象的内存布局。默认地址空间为0。
- p[n]:\<size>:\<abi>[:\<pref>][:\<idx>] 指定指针大小，abi，pref。pref是可选的，默认为abi。idx为索引大小，用来做地址计算。如果未指定，默认为指针大小。所有的地址大小都是以位为单位。n为地址空间，是可选的，未指定的话，为默认的地址空间0。n必须是[1,2^23]之间
- i\<size>:\<abi>[:\<pref>] 指定整数类型的对齐属性。size以位为单位的整数大小。size必须是[1,2^23]之间。pref是可选的，默认为abi
- v\<size>:\<abi>[:\<pref>] 指定vector类型的对齐属性。size以位为单位的整数大小。size必须是[1,2^23]之间。pref是可选的，默认为abi
- f\<size>:\<abi>[:\<pref>] 指定浮点类型的对齐属性。size以位为单位的整数大小。只有target支持的size才行。32（float）和64（double)被所有平台支持，80或者128在某些平台支持。 size必须是[1,2^23]之间。pref是可选的，默认为abi
- a:\<abi>[:\<pref>] 聚合类型的对象的对齐属性。pref是可选的，默认为abi
- F\<type>\<abi> 函数指针的对齐属性。type有如下可选项：
  1. i:函数指针和函数的对齐不相关，是abi的倍数
  2. h:函数指针对齐是函数的对齐的倍数，是abi的倍数
- m:\<mangling> 如果指定了，则LLVM的名称会被修饰。带有修饰逃逸字符\01前缀的符号会直接传递给汇编器。可选的重整选项为：
  1. e:elf修饰:私有符号得到一个.L前缀
  2. l:GOFF修饰:私有符号得到@前缀
  3. m:Mips修饰:私有符号得到$前缀
  4. o:Mach-O 修饰：私有符号使用L前缀，其他符号使用_前缀
  5. x:Windows x86 COFF 修饰：私有符号获得通常的前缀。普通 C 符号获得一个 _ 前缀。__stdcall,__fast_call,__vectorcall 函数有通常的修饰，添加@N，N是参数字节数.c++ 以开头的符号不会被修饰
  6. w：Windows COFF 修饰：和相似，除了正常的C符号不会获得_前缀
  7. a：COFF修饰：私有变量获得L..前缀
- n\<size1>:\<size2>:\<size3>... 对于指定的平台，指定原生的整数宽度。
- ni:\<address space0>:\<address space1>:\<address space2>... 指定地址空间为非整数指针类型 s 的指针类型。不能将0地址空间指定为非整数。

在构造给定目标的数据布局时，LLVM 首先使用默认的规范集，然后(可能)被 datalayout 关键字中的规范覆盖。下面列出了默认的规范:
- e-小端
- p:64:64:64-64位指针与64位对齐。
- p[n]:64:64:64-假定其他地址空间与默认地址空间相同。
- S0-未指定自然堆栈对齐方式
- i1:8:8-i1是8位(字节)对齐的
- i8:8:8-i8是8位(字节)对齐的
- i16:16:16-i16是16位对齐的
- i32:32:32-i32是32位对齐的
- i64:32:64-i64的ABI对齐方式为32位，但首选的对齐方式为64位
- f16:16:16-half是16位对齐的
- f32:32:32-float是32位对齐的
- f64:64:64-double是64位对齐的
- f128:128:128-quad是128位对齐的
- v64:64:64-64位向量是64位对齐的
- v128:128:128-128位向量是128位对齐的
- a:0:64-聚合是64位对齐的

当 LLVM 确定给定类型的对齐方式时，它使用以下规则:
1. 如果所寻求的类型与其中一个规范完全匹配，则使用该规范。
2. 如果未找到匹配项，且所寻找的类型为整数类型，则使用大于所寻找类型的位宽的最小整数类型。如果所有规范都不大于位宽，则使用最大整数类型。例如，给定上面的默认规范，i7类型将使用 i8(下一个最大值)的对齐方式，而 i65和 i256都将使用 i64(指定的最大值)的对齐方式。

函数的数据布局字符串可能与您期望的不同。值得注意的是，这并不是代码生成器应该使用什么对齐方式的前端规范。

相反，如果指定了，则需要目标数据布局来匹配最终代码生成器所期望的结果。中级优化器使用此字符串来改进代码，并且只有当它与最终代码生成器所使用的内容匹配时才能正常工作。没有任何方法可以生成不将这个特定于目标的细节嵌入到 IR 中的 IR。如果你没有指定字符串，默认的规范将被用来生成一个数据布局，优化阶段将相应地操作，并且相对于这些默认的规范，将目标特异性引入到 IR 中。

## 目标三元祖
模块可以指定描述目标主机的目标三重字符串。目标三元组的语法很简单:
```llvm
target triple = "x86_64-apple-macosx10.7.0"
```
'-'分割的字符串格式如下：
```llvm
ARCHITECTURE-VENDOR-OPERATING_SYSTEM
ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT
```
此信息被传递到后端，以便它为适当的体系结构生成代码。可以在命令行上使用-mthree 命令行选项覆盖这一点。

## 对象生命周期
内存对象(或简称对象)是由内存分配(如分配、堆分配调用和全局变量定义)保留的内存空间区域。一旦分配，存储在区域中的字节只能通过基于分配值的指针读取或写入。如果一个不基于对象的指针尝试读取或写入对象，那么它就是未定义行为。

内存对象的生存期是决定其可访问性的属性。除非另有说明，否则内存对象在其分配之后是活跃的，在其释放之后是消逝的。访问一个不存在的内存对象是未定义行为。但是不对其解引用的操作，如 getelementptr、 ptrtoint 和 icmp，会返回一个有效的结果。这解释了这些指令在影响对象生命周期的操作中的代码运动。可以使用 llvm.lifetime.start 和 llvm.lifetime.end 内部函数调用显式指定堆栈对象的生命周期。

## 指针别名规则
任何内存访问都必须通过与内存访问的地址范围相关联的指针值来完成，否则行为是未定义的。根据以下规则，指针值与地址范围相关联：
- 指针值与它所基于的任何值关联的地址相关联。
- 全局变量的地址与变量存储的地址范围相关联。
- 分配指令的结果值与所分配存储器的地址范围相关联。
- 默认地址空间中的空指针与没有地址关联。
- 任何地址空间中的 undef 值都与没有地址关联
  
基于其他指针值的指针值基于以下规则：
- 从getelementptr操作形成的指针的类型是getelementptr操作的指针类型
- 一个向量 getelementptr 操作的结果指针基于 getelementptr的向量的指针类型
- bitcast的结果值基于bitcast的操作数
- 由 inttoptr 形成的指针值基于(直接或间接)对指针值的计算有贡献的所有指针值。
- 规则是传递的

请注意，这个"基于"的定义有意与 C99中的"基于"定义相似，尽管它稍弱一些。

LLVM IR 不将类型与内存关联。加载的结果类型仅指示要加载的内存的大小和对齐方式，以及对值的解释。类似地，store的第一个操作数类型仅指示存储区的大小和对齐方式。
因此，基于类型的别名分析，又名 TBAA，又名-fstric- 别名，不适用于一般的未修饰 LLVM IR。元数据可用于编码附加信息，专门的优化通过这些信息可用于实现基于类型的别名分析。

## 指针捕获
给定一个函数调用和一个作为参数传递或存储在调用之前的内存中的指针，如果指针的任何部分在调用中被拷贝，且在调用之后仍然存在，那么调用就会捕获该指针。确切地说，如果下列一个或多个条件符合，则捕获指针:
1. 调用存储指针的任何位，将信息传送到一个位置，并且在调用退出后，调用方可以从该位读取存储的位。
```llvm
@glb  = global ptr null
@glb2 = global ptr null
@glb3 = global ptr null
@glbi = global i32 0

define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {
  store ptr %a, ptr @glb ; %a is captured by this call

  store ptr %b,   ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below
  store ptr null, ptr @glb2

  store ptr %c,   ptr @glb3
  call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured
  store ptr null, ptr @glb3

  %i = ptrtoint ptr %d to i64
  %j = trunc i64 %i to i32
  store i32 %j, ptr @glbi ; %d is captured

  ret ptr %e ; %e is captured
}
```
2. 调用存储指针的任何位，将信息传送到一个位置，通过同步，另一个线程可以安全地从该位读取存储的位。
```llvm
@lock = global i1 true

define void @f(ptr %a) {
  store ptr %a, ptr* @glb
  store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb
  store ptr null, ptr @glb
  ret void
}
```
3. 调用的行为取决于携带信息的指针的任何位。
```llvm
@glb = global i8 0

define void @f(ptr %a) {
  %c = icmp eq ptr %a, @glb
  br i1 %c, label %BB_EXIT, label %BB_CONTINUE ; escapes %a
BB_EXIT:
  call void @exit()
  unreachable
BB_CONTINUE:
  ret void
}
```
4. 指针通过volatile访问的方式被使用
   
某些内存访问，比如 load 的、 store 的和 llvm.memcpy 的可能被标记为volatile。优化器不能更改volatile操作的数量，也不能相对于其他volatile操作更改其执行顺序。优化器可能会改变volatile操作相对于非易失性操作的顺序。这不是 Java 的volatile，也没有跨线程同步行为。

volatile 加载或存储可能具有额外的特定于目标的语义。任何volatile操作都可能产生副作用，任何volatile操作都可以读取和/或修改无法通过常规加载或存储在此模块中访问的状态。volatile操作可能使用不指向内存的地址(如 MMIO 寄存器)。这意味着编译器可能不会使用volatile操作来证明对该地址的非volatile访问具有已定义的行为。

volatile访问允许的副作用是有限的。如果指定地址的非volatile存储是合法的，则volatile操作可能会修改该地址的内存。volatile操作不能修改正在编译的模块可访问的任何其他内存。volatile操作可能不会调用当前模块中的任何代码。

一般情况下(没有目标特定上下文) ，volatile操作的地址空间不能更改。当解除对无效指针的引用时，不同的地址空间可能具有不同的捕获行为。

编译器可能会假设执行会在执行了volatile操作后继续进行，因此修改内存或者可能有未定义行为的操作可以在执行了volatile操作后继续执行。

作为前面规则的一个例外，编译器不能假定执行将在volatile存储操作之后继续。这个限制是必要的，以支持 C 语言中有意存储到无效指针以使程序崩溃的常见模式。将来，允许前端控制这种行为可能是有意义的。

IR 级的可变负载和存储不能安全地优化为 llvm.memcpy 或 llvm.memmove 内部函数，即使这些内部函数被标记为可变。同样，后端不应该拆分或合并目标合法的volatile加载/存储指令。类似地，IR 级volatile负载和存储不能从整数更改为浮点，反之亦然。

## 并发操作的内存模型
LLVM IR没有定义任何启动并行执行线程或注册信号处理程序的方法。尽管如此，还是有特定于平台的方式来创建它们，并且我们定义LLVM
IR他们存在的行为。该模型受C++ 0x内存模型的启发。

有关此模型的更多非正式介绍，请参阅[LLVM原子指令和并发指南。](https://llvm.org/docs/Atomics.html)

我们将发生之前的偏序定义为最小偏序(partial order).

是单线程程序顺序的超集，并且
当同步b时，包含一个从a到b的边缘。通过特定于平台的技术（如pthread锁，线程创建，线程连接等）以及原子指令引入同步对。（另请参阅[原子内存排序约束](https://llvm.org/docs/LangRef.html#ordering)）。
请注意，程序顺序不会在线程和该线程内执行的信号之间引入边界之前发生的事件。

每个（定义的）读取操作（加载指令，memcpy，原子加载/读取-修改-写入等）R读取由（定义的）写入操作写入的一系列字节（存储指令，原子存储/读取-修改-写入，memcpy等）。就本节而言，已初始化的全局变量被认为是写入了初始化程序，它是原子化的，并且在任何其他读或写有问题的内存之前发生。对于读R的每个字节，Rbyte 可能会看到对相同字节的任何写入，除了：

- 如果write~1~发生在write~2~之前，并且write~2~发生在R~byte~之前，则R~byte~不会看到Write~1~。
- 如果R~byte~在write~3~之前发生，则R~byte~不会看到write~3~。
  
鉴于该定义，R~byte~定义如下：

- 如果R是volatile的，则结果与目标相关。（volatile应该提供可以在C/C++中支持sig_atomic_t的保证，并且可以用于访问不像正常内存那样行为的地址，它通常不会提供跨线程同步。）
- 否则，如果没有写入R~byte~发生之前的相同字节，则Rbyte会对该字节返回undef。
- 否则，如果R~byte~可能只看到一次写入，则R~byte~将返回该写入写入的值。
- 否则，如果R是原子的，并且所有写入的R~byte~可能看到的都是原子的，它将选择其中一个写入的值。请参阅[原子内存排序约束部分](## 调用约束)了解如何进行选择的其他限制条件。
- 否则R~byte~返回undef。
  
R返回由它读取的一系列字节组成的值。这意味着该值内的一些字节可能是undef，没有整个值的undef。请注意，这只定义了操作的语义;这并不意味着目标将发出多个指令来读取一系列字节。

请注意，在没有使用任何原子内在函数的情况下，此模型仅对单线程执行所需的IR转换放置一个限制：将store引入可能不会被存储的字节一般是不允许的。（具体来说，在另一个线程可以写入和读取地址的情况下，引入一个store可以改变一个load，可以看到只有一个写入可能看到多个写入的load。）

## 原子内存排序约束
原子指令（cmpxchg，atomicrmw，fence，atomic load和atomic store）使用排序参数来确定与它们同步的同一地址上的其他原子指令。这些语义是从Java和C++ 0x中借用的，但是更通俗一点。如果这些描述不够精确，请检查这些规格（请参阅Atomic指南中的规格参考）。fence指令对待这些排序有些不同，因为他们没有收到地址。有关详细信息，请参阅该说明文档。

有关排序约束的更简单介绍，请参阅LLVM原子指令和并发指南。

- unordered:
可以读取的一组值由发生前的部分顺序决定。除非某些操作写入，否则无法读取值。这旨在提供足够强大的保证来模拟Java的非volatile共享变量。此顺序不能指定为读取-修改-写入操作;它不足以使它们以任何有趣的方式成为原子。
- monotonic:
除了保证unordered之外，每个地址上的monotonic操作都有单个总顺序。所有修改顺序都必须与先发生的顺序兼容。不能保证修改顺序可以合并到整个程序的全局总顺序中（而这通常是不可能的）。原子读取-修改-写入操作（cmpxchg和atomicrmw）中的读取会在写入值之前立即读取修改顺序中的值。如果在同一地址的另一个原子读取之前发生一次原子读取，则稍后的读取必须在地址的修改顺序中看到相同的值或更高的值。这不允许重新排序monotonic（或更强大）的操作。如果地址是由一个线程monotonic-ally写入和其他线程monotonic-ally读取的– 反复读取该地址，其他线程最终必须看到写入。这对应于C++
0x/C1x的memory_order_relaxed。
- acquire:
除了monotonic的保障，一个进行同步边缘可以与形成release操作。这是为了模拟C++的memory_order_acquire。
- release:
除了保证monotonic，如果此操作写入随后由acquire操作读取的值，则与该操作同步。（这不是一个完整的描述;请参阅发布序列的C++0x定义。）这对应于C++ 0x/C1x的memory_order_release。
- acq_rel （获取+释放）: acquire和release操作作为地址的一部分。这对应于C
++ 0x / C1x memory_order_acq_rel。
- seq_cst （顺序一致）:
除了保证acq_rel（acquire对于仅读取的操作，release对于仅写入的操作），对于所有地址上的所有顺序一致的操作，存在全局总顺序，这与在部分顺序之前发生的以及与所有受影响地址的修改顺序一致。每个按顺序一致的读取将按照此全局顺序查看最后一个先前写入相同地址的内容。这对应于C
++ 0x / C1x memory_order_seq_cst和Java volatile。
如果标记了一个原子操作syncscope("singlethread")，它只会同步并仅参与在同一线程中运行的其他操作（例如，在信号处理程序中）的seq_cst总排序。

如果标记了一个原子操作syncscope("\<target-scope>")，其中 \<target-scope>是目标特定的同步范围，那么它与目标相关，如果它与其他操作的seq_cst总排序同步并参与其中。

否则，未标记的原子操作syncscope("singlethread") 或syncscope("\<target-scope>") 与同步和参与未标记syncscope("singlethread")或syncscope("\<target-scope>")的其它操作的seq_cst总排序
。

## LLVM IR 浮点环境
默认的LLVM浮点环境假定浮点指令没有副作用。结果假设为舍入到舍入模式。此环境中不保留浮点异常状态。因此，在这些示例中，不会尝试创建或保留无效操作（SNaN）或零除异常。

这种无异常假设的好处是可以自由地推测浮点运算，而不需要对浮点模型进行任何其他快速数学松弛。

需要与此不同的行为的代码应使用 Constrained Floating-Point Intrinsics

## 快速数学标志
LLVM IR浮点运算（fadd，fsub，fmul，fdiv，frem，fcmp）和call可以使用以下标志来启用其他不安全的浮点转换。

- nnan: 没有NaNs - 允许优化假设参数和结果不是NaN。如果一个参数是nan，或者结果是一个 nan，它会产生一个有害的值。
- ninf: 无Infs – 允许优化假设参数和结果不是+/-Inf。如果一个参数是+/-Inf，或者结果是+/-Inf，它会产生一个有害的值。
- nsz: 无有符号的零 – 允许优化将零参数或结果的符号视为无关紧要。
- arcp: 允许互惠(Reciprocal) – 允许优化使用参数的倒数而不是执行除法。
- contract: 允许浮点收缩（例如，融合乘法，然后将加法融合为融合乘加）。
- afn: 近似函数 – 允许用近似计算代替函数（sin，log，sqrt等）。有关可应用于LLVM的内在数学函数的位置，请参阅浮点内在定义。
- reassoc: 允许为浮点指令重新关联转换。这可能会显着改变浮点结果。
- fast: 这个标志暗示其他所有的。

## Use-list Order Directives
- [] todo

## 源文件名
源文件名字符串被设置为原始模块标识符，例如，当从源文件通过 clang 前端进行编译时，该标识符将是已编译的源文件的名称。并在IR 和位码文件中保留。
当前，这对于为配置文件数据中使用的本地函数生成一致的唯一全局标识符是必需的，该标识符将源文件名置于本地函数名之前。
源文件名的语法很简单:
```llvm
source_filename = "/path/to/source.c"
```

## 类型系统
LLVM 类型系统是中间表示的重要特征之一。类型化允许直接在中间表示上执行许多优化，而不必在转换之前进行额外的分析。强类型系统使得读取生成的代码更加容易，并且支持新颖的分析和转换，而这些分析和转换在正常的三个地址代码表示上是不可行的。
### void类型
void类型不代表任何值，没有大小
```llvm
void
```

### 函数类型
函数类型可以认为是一个函数签名，包括返回值，和一些函数参数。返回类型可以是void或者第一级类型，除了标志或元数据类型
```llvm
<returntype> (<parameter list>)
```
paremeter list 由逗号分割的类型标识符。可选的包括...，表示可变的参数。可变参数函数可以通过可变参数处理内在函数访问。
例如：
```llvm
i32 (i32) ;参数为一个i32返回值也是i32
i32 (ptr,...) ;参数为一个i32，和一个可变参数列表，返回i32，prinft就是这个类型
{i32,i32} (i32) ;参数为一个i32，返回值为一个结构体，包含两个i32
```

### 第一类类型
第一类类型是最重要的，这些类型的值是唯一可以通过指令生成的值。

#### 单值类型
从 CodeGen 的角度来看，这些类型在寄存器中是有效的。
**整数类型**
整数类型是一种非常简单的类型，它只是为所需的整数类型指定一个任意的位宽。可以指定从1位到223(约800万)的任何位宽度。
语法：
```llvm
iN
```
例如
```llvm
i1 一个位的整数
i8 8位的整数
i1942652 超过100万位的整数
```

**浮点类型**
- half
- bfloat
- float
- double
- fp128
- x86_fp80
- ppc_fp128

hafl,float,double,fp129 遵从IEEE-754-2008规范

**x86_amx类型**
X86 _ AMX 类型表示 x86计算机上的 AMX 瓦片寄存器中保存的值。它所允许的操作非常有限。只有很少的内置函数是允许的: 跨度加载和存储，零和点积。此类型不允许使用任何指令。没有这种类型的参数、数组、指针、向量或常量。
```llvm
x86_amx
```

**x86_xmm类型**
X86_xmm 类型表示 x86计算机上的 MMX 寄存器中保存的值。它所允许的操作非常有限：参数，返回值，加载和存储，和转换。用户指定的 MMX 指令被表示为带有这种类型的参数和/或结果的内部调用或者间接调用。没有这种类型的数组、向量或常量。
```llvm
x86_mmx
```

**指针类型**
指针类型 ptr 用于指定内存位置。指针通常用于引用内存中的对象。

指针类型可以有一个可选的地址空间属性，定义指向对象所在的编号地址空间。例如，ptr addrspace (5)是指向地址空间5的指针。

默认地址空间为零。

非零地址空间的语义是特定于目标的。在任何地址空间中，通过不可解除引用的指针进行的内存访问都是未定义行为的。**只有在地址空间0中，位值为0的指针才被认为是不可解引用的**，除非函数被标记为 **null_point_is_void** 属性。

如果可以证明某个对象可以通过具有不同地址空间的指针访问，则可以修改该访问以使用该地址空间。如果操作是volatile的，则异常。

在 LLVM 15之前，指针类型还指定了一个指针类型，例如 i8 * 、[4 x i32] * 或 i32(i32 *) * 。在 LLVM 15中，这样的"类型化指针"在非默认选项下仍然受到支持。有关更多信息，请参见[不透明指针文档](https://llvm.org/docs/OpaquePointers.html)。

**向量类型**
向量类型是表示元素向量的简单派生类型。当使用单个指令(SIMD)并行操作多个原始数据时，将使用向量类型。向量类型需要大小(元素数量)、基础原始数据类型和可伸缩属性来表示在编译时确切的硬件向量长度未知的向量。向量类型被认为是**第一类**。
**内存布局：**
一般来说，向量元素在内存中的布局方式与数组类型相同。只要向量元素是字节大小的，这样的类比就可以很好地工作。但是，当向量的元素不是字节大小时，就会变得有点复杂。描述布局的一种方法是考虑当向量(例如 < N x iM >)被比特转换为具有 N * M 位的整数类型时会发生什么，然后遵循将这种整数存储到内存中的规则。

从向量类型到标量整数类型的位转换将看到元素被打包在一起(没有填充)。元素插入到整数中的顺序取决于字节顺序。对于小端计算机元素0放在整数的最低有效位中，对于大端计算机元素0放在最高有效位中。
以向量为例，比如 < i41，i42，i43，i45 > ，再加上我们可以用一个位转换后跟一个整数存储来替换向量存储，我们得到了大端计算的的这个结果:
```llvm
%val = bitcast <4 x i4> <i4 1, i4 2, i4 3, i4 5> to i16

; 从向量位转换到一个整数类型，可以被认为是每个元素的连接
;   %val 现在为值0x1235.

store i16 %val, ptr %ptr

; 内存中的内容为 (字节编址的):
;
;    [%ptr + 0]: 00010010  (0x12)
;    [%ptr + 1]: 00110101  (0x35)
```
小端示例如下:
```llvm
%val = bitcast <4 x i4> <i4 1, i4 2, i4 3, i4 5> to i16

;   %val 现在为值 0x5321.

store i16 %val, ptr %ptr

; 内存中的内容为 (字节编址的):
;
;    [%ptr + 0]: 01010011  (0x53)
;    [%ptr + 1]: 00100001  (0x21)
```

当 < N * M > 不能被字节大小整除时，没有指定确切的内存布局(就像对于相同大小的整型一样)。这是因为当类型大小小于类型的存储大小时，不同的目标可以将填充放置在不同的位置。
```llvm
< <# elements> x <elementtype> >          ; Fixed-length vector
< vscale x <# elements> x <elementtype> > ; Scalable vector
```
元素的数量是一个大于0的常数整数值; element 类型可以是任何整数、浮点或指针类型。**大小为零的向量是不允许的**。对于可伸缩向量，元素的总数是指定数量元素的常数倍(称为 vscale) ; vscale 是一个正整数，在编译时是未知的，在运行时所有可伸缩向量的硬件相关常量相同。因此，特定的可伸缩向量类型的大小在 IR 中是恒定的，即使在运行时才能确定确切的字节大小。
示例：
```llvm
<4 x i32>	Vector of 4 32-bit integer values.
<8 x float>	Vector of 8 32-bit floating-point values.
<2 x i64>	Vector of 2 64-bit integer values.
<4 x ptr>	Vector of 4 pointers
<vscale x 4 x i32>	Vector with a multiple of 4 32-bit integer values.
```
#### 标签类型
代表了代码的标签
```llvm
label
```

#### 令牌类型
当值与指令关联时使用令牌类型，但该值的所有用法都不得试图内省或模糊它。因此，phi和select指令类型为令牌类型是不合适的
```llvm
token
```

#### 元数据类型
元数据类型表示嵌入的元数据。除函数参数外，不得从元数据创建派生类型。
```llvm
metadata
```

#### 聚合类型
聚合类型是派生类型的一个子集，可以包含多个成员类型。数组和结构是聚合类型。向量不被视为聚合类型。

**数据类型**
连续的同一个类型派生的类型，数组类型需要单个元素的类型，以及元素个数
```llvm
[<# elements> x <elementtype>]
```
元素的数量是一个常量整数值; 元素类型可以是任何具有大小的类型。
示例：
```llvm
[40 x i32]	Array of 40 32-bit integer values.
[41 x i32]	Array of 41 32-bit integer values.
[4 x i8]	Array of 4 8-bit integer values.
```
多维数组：
```llvm
[3 x [4 x i32]]	3x4 array of 32-bit integer values.
[12 x [10 x float]]	12x10 array of single precision floating-point values.
[2 x [3 x [4 x i16]]]	2x3x4 array of 16-bit integer values.
```
**对于超出静态类型所隐含的数组末尾的索引没有限制(尽管在某些情况下，对于超出分配对象边界的索引也有限制)。这意味着一维"可变大小的数组"寻址可以实现在 LLVM 与零长度数组类型。例如，LLVM 中" pascal 样式数组"的实现可以使用类型"{ i32，[0 x float ]}"。**

**结构类型**
结构类型用于在内存中一起表示数据成员的集合。结构的元素可以是任何具有大小的类型。

通过使用'getelementptr'指令获取指向字段的指针，再使用'load'和'store'来访问指针指向的内存。使用'extractvalue'和'insertvalue'指令访问寄存器中的结构。

结构可以选择是"压缩"结构，其指示结构的对齐是一个字节，并且元素之间没有填充。在非压缩结构中，字段类型之间的填充按照在模块中定义的DataLayout字符串方式插入，该模块需要与基础代码生成器的预期匹配。

结构可以是"字面的"或"识别符"。字面结构与其他类型（例如{i32, i32}*）内联定义，而标识类型始终在顶层使用名称定义。文字类型被其内容所独占，因为没有办法编写它们，所以永远不会递归或不透明。识别符的类型可以是递归的，可以是不透明的，并且永远不会被分离。

```llvm
%T1 = type { <type list> }     ; 标识符化的常规结构类型
%T2 = type <{ <type list> }>   ; 标识符化的paceed结构类型
```

```llvm
{ i32, i32, i32 }	;3个i32元组
{ float, ptr }	;pair,
<{ i8, i32 }> ;packed的结构
```

**不透明结构类型**
不透明结构类型用于表示没有指定主体的命名结构类型。这符合（例如）正向声明结构的C概念。
```llvm
%X = type opaque≤
%52 = type opaque
```
例如
```llvm
opaque	不透明类型
```

## 常量
### 简单常量
**布尔常量**: 两个字符串true和false都是该i1类型的有效常量。
**整型常量**: 标准整数（如4）是整数类型的常量。负数可能与整数类型一起使用。
**浮点常量**: 浮点常量使用标准十进制表示法（例如123.421），指数表示法（例如1.23421e+2）或更精确的十六进制表示法。汇编器需要浮点常量的精确十进制值。例如，汇编程序接受1.25，但拒绝1.3，因为1.3是二进制中的重复小数。浮点常量必须具有浮点类型。
**空指针常量**: 标识符'null'被识别为空指针常量，并且必须是指针类型。
**令牌(Token)常量**: 标识符'none'被识别为空的标记常量，并且必须是标记类型。

常量的一个非直观符号是浮点常量的十六进制形式。例如，形式为double 0x432ff973cafa8000等同于（但难以阅读）double 4.5e+15。唯一需要十六进制浮点常量（以及它们由反汇编程序生成的唯一时间）是必须发出浮点常量但不能用合理数目的十进制浮点数表示的浮点常量数字。例如，NaN's，infinities和其他特殊值以IEEE十六进制格式表示，因此汇编和反汇编不会导致常量中的任何位发生更改。

当使用十六进制形式时，half，float和double类型的常量使用上面显示的16位数字形式表示（与IEEE754的double表示符合double）;然而，half和float值必须分别精确表示为IEEE 754的半精度和单精度。十六进制格式总是用于长双，并有三种形式的长双。x86使用的80位格式表示0xK后跟20个十六进制数字。PowerPC使用的128位格式（两个相邻的双精度）0xM由32个十六进制数字表示。IEEE 128位格式0xL由32个十六进制数字表示。长双打只有在你的目标上的长双重格式匹配时才有效。IEEE16位格式（半精度）由表示0xH后跟4个十六进制数字。所有的十六进制格式都是big-endian（左边的符号位）。

注意：没有x86_mmx类型的常量。

### 复杂常量
复杂常量是简单常量和较小复常量的（可能递归）组合。

**结构常数**：
结构常量用类似于结构类型定义的符号表示（逗号分隔的元素列表，用大括号（{}）括起来）。例如：“{ i32 4, float 17.0, i32* @G }，其中“@G被声明为“@G = external global i32。结构常量必须具有结构类型，并且元素的数量和类型必须与该类型指定的类型匹配。

**数组常量**：
数组常量用类似于数组类型定义的符号表示（逗号分隔的元素列表，用方括号（[]）括起来）。例如：[ i32 42, i32 11, i32 74 ]。数组常量必须具有数组类型，并且元素的数量和类型必须与该类型指定的数量和类型相匹配。作为一种特殊情况，字符数组常量也可以用前缀表示为双引号字符串。例如：**"c"Hello World\0A\00"。**

**矢量(Vector)常量**：
向量常量用类似于向量类型定义的符号表示（逗号分隔的元素列表，由小于/大于（<>））围绕）。例如：< i32 42, i32 11, i32 74, i32 100 >。向量常量必须具有向量类型，并且元素的数量和类型必须与该类型指定的类型匹配。

**零初始化**:
字符串zeroinitializer可用于将零值初始化为任何类型的零，包括标量和聚合类型。这通常用于避免必须打印大型零初始化器（例如，用于大型数组），并且始终完全等同于使用显式零初始化器。

**元数据节点**
元数据节点是一个没有类型的常量元组。例如：!{!0, !{!2, !0}, !"test"}。元数据可以引用常量值，例如：!{!0, i32 0, i8* @global, i64 (i64)* @function, !"str"}。与其他类型化的常量不同，它们被解释为指令流的一部分，元数据是附加附加信息的地方，例如调试信息。

### 全局变量和函数的地址
全局变量和函数的地址总是隐式有效（链接时）的常量。当使用全局标识符并且总是有指针类型时，这些常量被明确引用。例如，以下是合法的LLVM文件：
```llvm
@X = global i32 17
@Y = global i32 42
@Z = global [2 x i32*] [ i32* @X, i32* @Y ]
```
### 未定义的值
字符串undef可以用于任何需要常量的地方，并且表示该值的用户可能会收到未指定的位模式。未定义的值可以是任何类型（除了label或void），并且可以在任何允许常量的地方使用。

如果可能的话，应该使用“有害”值(在下一节中描述)代替"undef"。有毒值比 undef 更强，可以进行更多的优化。只是"undef"的存在阻碍了某些优化(参见下面的例子)。

未定义的值非常有用，因为它们向编译器指出，无论使用什么值，该程序都已定义良好。这为编译器提供了更多的优化自由度。下面是一些有效的（可能令人惊讶的）转换的例子（在伪IR中）：
```llvm
  %A = add %X, undef
  %B = sub %X, undef
  %C = xor %X, undef
Safe:
  %A = undef
  %B = undef
  %C = undef
```
这是安全的，因为所有的输出位都受undef位的影响。任何输出位都可以有一个零或一个依赖的输入位。
```llvm
  %A = or %X, undef
  %B = and %X, undef
Safe:
  %A = -1
  %B = 0
Safe:
  %A = %X  ;; By choosing undef as 0
  %B = %X  ;; By choosing undef as -1
Unsafe:
  %A = undef
  %B = undef
```
这些逻辑操作的位不总是受输入的影响。例如，如果%X有一个零位，那么and操作的输出将始终为该位的零，而不管undef的相应位是什么。因此，优化或假设and的结果是undef是不安全的。但是，假设undef的所有位都可以是0，并且将and优化为0是安全的。同样，假设可以设置undef的or操作的所有位是安全的，允许or被折叠为-1。

```llvm
  %A = select undef, %X, %Y
  %B = select undef, 42, %Y
  %C = select %X, %Y, undef
Safe:
  %A = %X     (or %Y)
  %B = 42     (or %Y)
  %C = %Y
Unsafe:
  %A = undef
  %B = undef
  %C = undef
```

这组例子表明，未定义的select（和条件分支）条件可以采取任何方式，但它们必须来自两个操作数中的一个。在%A例子中，如果%X和%Y是两个已知具有明显的低位，那么%A就必须有一个清除低位。然而，在这个%C例子中，优化器被允许假设undef操作可以是和%Y相同的，允许整个select被消除。
```llvm
  %A = xor undef, undef

  %B = undef
  %C = xor %B, %B

  %D = undef
  %E = icmp slt %D, 4
  %F = icmp gte %D, 4

Safe:
  %A = undef
  %B = undef
  %C = undef
  %D = undef
  %E = undef
  %F = undef
```
这个例子指出两个undef操作不一定相同。这对于人们来说可能是令人惊讶的（并且也匹配C语义），他们认为X^X总是零，即使X未定义也是如此。由于多种原因，这是不正确的，但简单的答案是，一个undef变量可以在其“生存范围”内随意改变它的值。这是真的，因为这个变量实际上并没有生存范围。相反，该值是从任意寄存器中逻辑读取的，这些寄存器恰好在需要时发生变化，因此该值不一定随时间变化。事实上，%A和%C需要有相同的语法或核心LLVM“全部替换与使用”的概念将不成立。
```llvm
  %A = sdiv undef, %X
  %B = sdiv %X, undef
Safe:
  %A = 0
b: unreachable
```
这些示例显示了未定义的值和未定义的行为之间的关键区别。一个未定义的值（如undef）允许有一个任意的位模式。这意味着%A操作可以不断折叠为0，因为undef可能为零，并且零除以任何值为零。但是，在第二个例子中，我们可以做一个更积极的假设：因为undef允许它是一个任意值，我们可以假设它可能为零。由于被零除以具有未定义的行为，我们被允许假设该操作根本不执行。这允许我们删除分割和所有代码。由于未定义的操作“不可能发生”，因此优化器可以假定它发生在死代码中。
```llvm
a:  store undef -> %X
b:  store %X -> undef
Safe:
a: <deleted>
b: unreachable
```
存储的未定义的值可以被假设为不具有任何影响;
我们可以假设这个值被恰好与已经存在的相匹配的位覆盖。然而，一个存储到一个未定义的位置可能破坏任意的内存，因此，它具有未定义行为。

### 毒药值
中毒值是错误操作的结果。为了方便 Speculative_execution，许多指令在提供非法操作数时不会立即调用未定义行为，而是返回一个有毒值。可以在需要常量的任何地方使用字符串“剧毒”，并且诸如使用 nsw 标志进行 add 等操作可以产生剧毒值。

当其中一个参数是“毒药”时，大多数指令返回“毒药”。一个值得注意的例外是 select 指令。通过冻结指令可以阻止毒物的传播。

用 undef 值或类型的任何值替换带毒值是正确的。

目前在IR中无法表示毒物值;
它们只存在于某些操作的调用，如带有nsw标志的add操作。

毒药值行为是根据值依赖来定义的：

这意味着，如果使用一个有毒值作为指令操作数，而该操作数的任何值都会触发未定义行为，那么就会立即出现问题。值得注意的是，这包括(但不限于) :

- load，store的指针操作数，或者任何指针解引用指令（地址空间无关）
- Udiv、 sdiv、 urem 或 srem 指令的除数操作数。
- br指令的条件操作数
- call或invoke指令的调用操作数
- 当函数或调用调用站点在相应位置有 noundef 属性时，调用或调用指令的参数操作数。
- 如果函数或调用调用站点的返回值位置有 noundef 属性，则 ret 指令的操作数。

示例如下：
```llvm
entry:
  %poison = sub nuw i32 0, 1           ; Results in a poison value.
  %poison2 = sub i32 poison, 1         ; Also results in a poison value.
  %still_poison = and i32 %poison, 0   ; 0, but also poison.
  %poison_yet_again = getelementptr i32, ptr @h, i32 %still_poison
  store i32 0, ptr %poison_yet_again   ; Undefined behavior due to
                                       ; store to poison.

  store i32 %poison, ptr @g            ; Poison value stored to memory.
  %poison3 = load i32, ptr @g          ; Poison value loaded back from memory.

  %poison4 = load i16, ptr @g          ; Returns a poison value.
  %poison5 = load i64, ptr @g          ; Returns a poison value.

  %cmp = icmp slt i32 %poison, 0       ; Returns a poison value.
  br i1 %cmp, label %end, label %end   ; undefined behavior

end:
```

### 定义良好的值
给定一个程序执行，如果该值没有 undef 位，并且在执行过程中不是有害的，那么该值将得到很好的定义。如果聚合值或向量的元素定义良好，那么它就是定义良好的。不考虑聚合的填充，因为如果不将其存储到内存中并使用不同的类型加载它，它就不可见。

如果非向量类型的单值常数既不是“ undef”常数，也不是“剧毒”常数，那么它就是定义良好的常数。冻结指令的结果是明确的，不管它的操作数。

### 基本块的地址
语法: blockaddress(@function, %block)

blockaddress常数计算指定函数指定的基本块的地址，并总是有一个ptr addrspace(P) 类型。P包含基本块%block的函数的地址空间（通常是0）

取出基本块的地址是非法的


当用作indirectbr指令的操作指令时，或者用于与空值进行比较时，该值仅具有已定义的行为。标签地址之间的指针相等测试会导致未定义的行为

此值只有在用作indirectbr指令的操作数或用于与 null 进行比较时才具有定义的行为。标签地址之间的指针相等测试会导致出现未定义行为ーー不过，与 null 进行比较也是可以的，而且没有任何标签等于 null 指针。只要不检查位，这可以作为不透明指针大小的值传递。这允许对这些值执行 ptrtoint 和算术操作，只要在间接 indirectbr指令之前重新构造原始值。

最后，有些目标可能会在使用该值作为内联程序集的操作数时提供定义的语义，但这是目标特定的。

### DSO本地等价物
//todo

### NO CFI
使用 Control-Flow Integrity (CFI) ，“ no _ CFI”常量表示函数引用，在 LowerTypeTest 传递中，该函数引用不会被对 CFI 跳转表的引用替换。这些常量在需要引用实际函数体的低级程序(如操作系统内核)中可能很有用。

### 常量表达式
常量表达式用于允许涉及其他常量的表达式用作常量。常量表达式可以是任何第一类类型，并且可能涉及没有副作用的任何LLVM操作（例如，不支持加载和调用）。以下是常量表达式的语法：

trunc (CST to TYPE):
对常量执行trunc操作。
zext (CST to TYPE):
对常量执行zext操作。
sext (CST to TYPE):
对常量执行sext操作。
fptrunc (CST to TYPE):
将浮点常量截断为另一个浮点类型。CST的大小必须大于TYPE的大小。这两种类型都必须是浮点型。
fpext (CST to TYPE):
浮点将常量扩展为另一种类型。CST的大小必须小于或等于TYPE的大小。这两种类型都必须是浮点型。
fptoui (CST to TYPE):
将浮点常量转换为相应的无符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。
fptosi (CST to TYPE):
将浮点常量转换为相应的有符号整数常量。TYPE必须是标量或向量整数类型。CST必须是标量或向量浮点类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合整数类型，则结果未定义。
uitofp (CST to TYPE):
将无符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。
sitofp (CST to TYPE):
将有符号整数常量转换为相应的浮点常量。TYPE必须是标量或向量浮点类型。CST必须是标量或向量整数类型。CST和TYPE都必须是标量，或者具有相同数量元素的向量。如果该值不适合浮点类型，则结果未定义。
ptrtoint (CST to TYPE):
对常量执行ptrtoint操作。
inttoptr (CST to TYPE):
对常量执行inttoptr操作。这个真的很危险！
bitcast (CST to TYPE):
将常数CST转换为另一个TYPE。操作数的限制与bitcast指令的限制相同。
addrspacecast (CST to TYPE):
将指针CST的常量指针或常量向量转换为另一个地址空间中的另一个TYPE。操作数的约束与addrspacecast指令的约束相同。
getelementptr (TY, CSTPTR, IDX0, IDX1, ...)， getelementptr inbounds (TY, CSTPTR, IDX0, IDX1, ...):
对常量执行getelementptr操作。与getelementptr 指令一样，索引列表可能有一个或多个索引，这些索引对于“指向TY的指针”类型是有意义的。
select (COND, VAL1, VAL2):
对常量执行选择操作。
icmp COND (VAL1, VAL2):
对常量执行icmp操作。
fcmp COND (VAL1, VAL2):
对常量执行fcmp操作。
extractelement (VAL, IDX):
对常量执行extractelement操作。
insertelement (VAL, ELT, IDX):
对常量执行insertelement操作。
shufflevector (VEC1, VEC2, IDXMASK):
对常量执行shufflevector操作。
extractvalue (VAL, IDX0, IDX1, ...):
对常量执行extractvalue操作。索引列表的解释方式与“getelementptr”操作中的索引类似。至少必须指定一个索引值。
insertvalue (VAL, ELT, IDX0, IDX1, ...):
对常量执行insertvalue操作。索引列表的解释方式与“getelementptr”操作中的索引类似。至少必须指定一个索引值。
OPCODE (LHS, RHS):
执行LHS和RHS常量的指定操作。操作码可以是任何二进制或按位二进制操作。操作数的限制与相应指令的限制相同（例如，不允许对浮点值进行按位操作）。


## 其他值
//todo

## 元数据
LLVM IR 允许将元数据附加到程序中的指令和全局对象，这些对象可以将有关代码的额外信息传递给优化器和代码生成器。元数据的一个示例应用程序是源代码级调试信息。有两个元数据原语: 字符串和节点。

元数据没有类型，也不是值。如果从调用指令引用，则使用元数据类型。
所有元数据的语法都由一个叹号(’!’)标识。

当不应该根据节点的内容合并节点时，区分不同节点非常有用。当元数据操作数更改时，转换导致唯一冲突时，也可能发生此类冲突。

命名元数据是元数据节点的集合，可以在模块符号表中查找这些元数据节点。例如:
```llvm
!foo = !{!4, !3}
```
元数据可以用作函数参数:在这里，llvm.dbg.value 使用三个元数据参数:
```llvm
call void @llvm.dbg.value(metadata !24, metadata !25, metadata !26)
```

元数据可以附加到指令中。在这里，元数据! 21使用! dbg 标识符附加到 add 指令中:

```llvm
%indvar.next = add i64 %indvar, 1, !dbg !21
```

指令可能不具有具有相同标识符的多个元数据附件。

元数据还可以附加到函数或全局变量。这是元数据！22附加到 f1和 f2函数，而全局 g1和 g2使用！Dbg 标识符:
```llvm
declare !dbg !22 void @f1()
define void @f2() !dbg !22 {
  ret void
}

@g1 = global i32 0, !dbg !22
@g2 = external global i32, !dbg !22
```
与指令不同，全局对象(函数和全局变量)可能具有相同标识符的多个元数据附件。

转换需要删除它不知道或不知道它不能保存的任何元数据附件。目前，对于!func_sanitize, !type and !absolute_symbol,除非全局符号本身被删除，否则不能无条件删除它.



### 元数据节点和元数据字符串
元数据字符串是由双引号包围的字符串。它可以通过使用"\xx"(其中"xx"是两位十六进制代码)转义非打印字符来包含任何字符。例如:!"00测试"。
元数据节点用类似结构常数的符号表示(一个逗号分隔的元素列表，用大括号括起来，前面加一个叹号)。元数据节点可以将任何值作为其操作数。例如:
```llvm
!{ !"test\00", i32 10}
```


## 模块标志元数据

## 嵌入式对象名称元数据

## 
