### 类型多态
- 子类型多态：子类型是一种和父类型关联的类型，程序例程或者函数，如果可以操作父类型，那么也可以操作子类型
 1. 定义类型S和T,如果S≤T,则S为T的子类型，任何接受T的地方，都可以安全都使用S。编程语言的类型系统本质上定义了它自己的子类型关系。
 2. 在面向对象语言中，一般多态指的是子类型多态
- 参数多态
一般面向对象编程语言中，参数多态指的泛型参数


### 里氏替换原则
1. 里氏替换原则定义了子类型关系，称为强行为子类型。由Barbara Liskov在1988年提出，是为了解决数据抽象和分层。基于可替代的概念
2. 具体内容是，假设一个基类B，一个子类S，S扩展了B，那么子类可以代替父类对象，而不会破坏程序。


### 函数子类型
参数逆变，返回值协变

### 行为子类型
1. 定义
    不仅仅保证语法正确，还要保证行为正确。一个对父类操作的行为结果，如果操作子类型也能获得一样的效果，那么这就是行为子类型。
正方形是长方形的子类，但是，如果行为定义为：T(S):S的长和宽没关系；T(长方形)满足，但是T(正方形)不满足。也就是说T(正方形)不是
T(长方形)的行为子类型。类型S是否是T的行为子类型仅仅和T的规范有关。与T的具体实现毫无关系。T可能没有具体实现。抽象类就没有具体实现。
对于所有讨论的类型，关于行为子类型，每个类型必须有明确的规范，这样才能有意义的讨论行为子类型。
例如:Stack<=Bag,定义Remove(Bag):从Bag删除一个元素，这个行为的结果就是一个元素删除了。很明显Remove(Stack) <= Remove(Bag)。
2. 验证
如何验证行为子类型？假设父类T定义了很多行为规范。对于T的每个行为M，如果子类S有更强的行为，则S是T的行为子类型。
如何有更强的行为：
- 弱化前置条件
- 强化后置条件
前置条件Ps和后置条件Qs赋予了某个行为的规范。

### 契约式设计（design by contract）
面相对象中的前置条件是契约式编程中的重要部分。契约式编程还包括后置条件和类不变量。根据契约式编程，函数调用者负责前置条件。

#### 前置条件和后置条件
1. 前置条件：条件或者一个谓词。在执行程序前，或者一个正式规范的一个操作执行前，必须为真。若果违反了前置条件，执行效果变得未定义
一般一个规范中规定了一个操作的前置条件，例如阶乘，必须要满足数据大于等于0。程序可以使用断言来测试前置条件。
***在继承时，重写或者实现某个方法时，必须也要按照父类的契约来写。前置条件可以改动，但是只能弱化，不能强化。***
2. 后置条件：条件或者一个谓词。在执行程序后，某些条件一定为真。一般方法调用比较关注后置条件。可以使用assert来测试后置条件。
***在继承时，重写或者实现某个方法时，必须也要按照父类的契约来写。后置条件可以改动，但是只能强化。***

