## 2.3原始类型和值
### 2.3.1 jvm支持的原始类型
   - numeric
     - integral
        - byte
        - short
        - int
        - long
        - char,16位，代表基本面的unicode编码（utf-16），默认为\u0000
     - floating-point
       - float
       - double
   - boolean
   - returnAddress
     - 是一个jvm中指令的指针
  
  在原始类型中，只有返回地址类型不和java编程语言中的类型对应
  
#### 2.3.2 浮点数类型和值
IEEE754不仅包含正负数，还有正负0，正负无穷，以及NaN值。NaN值表示非法操作的结果（除0）。float和double的NaN值为定义好的float.NaN和double.NaN
在java se 15前，浮点数用的是1985年的标准，而之后用的是2019年的标准

### 2.3.3 返回地址类型
返回地址在jvm的jsr, ret, 和 jsr_w指令中使用，返回地址类型不和java编程语言中的类型对应，且不能被运行程序修改

### 2.3.4 boolean类型
java中对boolean中的操作在编译后对应jvm中对int的操作。
jvm直接支持boolean数组，newarray指令能直接创建boolean数组。baload和bastore指令可以直接访问和修改boolean数组。jvm将true映射成int的1，将false映射成int的0


## 2.4 引用类型和值（reference）
三种引用类型：类、数组、接口。这三种类型的值都是对动态创建的类实例、数组、或者实现了接口的类实例的引用。数组类型的元素类型一定是原始类型、接口类型或者类类型。引用类型的初始值为null，可以转换为**任何**类型

## 2.5运行时数据域
jvm在运行时会创建多个数据区域，有些是jvm启动就会创建的，在jvm关闭时销毁；有些是每创建一个线程就会创建的，线程结束后销毁

### 2.5.1 pc寄存器
jvm支持多个线程同时执行。每个jvm线程有自己的pc寄存器。在任何时刻，每个jvm线程都在执行当个方法（当前方法）。如果方法不是本地的（native），则pc值为当前执行指令的地址，如果是本地的，pc值**未定义**。pc寄存器足够宽，能够容纳returnAddress或者特定平台的本地指针

### 2.5.2 jvm栈
每个 Java 虚拟机线程都有一个私有的 Java 虚拟机堆栈，该堆栈与该线程同时创建。Java 虚拟机栈存储帧。Java 虚拟机堆栈类似于传统语言(如 C)的堆栈: 它保存局部变量和部分结果，并在方法调用和返回中发挥作用。因为 Java 虚拟机堆栈除了推送和弹出帧之外不会被直接操作，所以帧可能会被堆分配。Java 虚拟机堆栈的内存不需要是连续的。

这个规范允许 Java 虚拟机堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果 Java 虚拟机堆栈的大小是固定的，那么在创建该堆栈时，可以独立地选择每个 Java 虚拟机堆栈的大小

Java 虚拟机实现可以为程序员或用户提供对 Java 虚拟机栈初始大小的控制，以及在动态扩展或收缩 Java 虚拟机栈的情况下，对最大和最小大小的控制。

jvm栈有如下异常情况
- 如果某个线程需要一个大于其被允许的栈大小，则报stackoverflow异常
- 如果 Java 虚拟机堆栈可以动态扩展，并尝试进行扩展，但可用内存不足以影响扩展，或者如果可用内存不足以为新线程创建初始 Java 虚拟机堆栈，Java 虚拟机将抛出 OutOfMemory 错误。
  
### 2.5.3 堆
所有线程共享堆。堆是运行时数据域，用来创建类实例和数组。

堆在虚拟机**启动阶段**创建。堆内存被垃圾回收器回收。对象**从不显式**销毁。jvm没有特定的垃圾回收器，可以根据实现者的系统需求选择。堆的大小可以是固定的，也可以根据计算的需要进行扩展，如果不需要更大的堆，则可以缩小堆。堆的内存不需要是连续的。

jvm实现可以让程序员控制初始堆的大小，已经动态扩展下的最大和最小值

堆分配有如下异常：
- 如果计算所需的堆大小大于存储管理系统中可获得的，报OutOfMemoryError.

### 2.5.4 方法区（Method Area）
jvm有个所有线程共享的方法区。方法区和传统语言的text段是同义的。它用来存储每个类的结构，例如：运行时常量池，字段和方法数据，方法代码，以及构造器（接口和类初始化）。

方法区在虚拟机**启动阶段**创建。

尽管方法区域在逻辑上是堆的一部分，但是简单的实现可以选择不对其进行垃圾收集或压缩。此规范不强制要求方法区域的位置或管理已编译代码的策略。方法区域可以是固定大小的，或者可以根据计算的需要进行扩展，如果不需要更大的方法区域，则可以进行收缩。方法区域的内存不需要是连续的。

jvm实现可以让程序员控制方法区的初始大小，已经动态扩展下的最大和最小值

异常情况：
- 如果方法区的内存不能满足分配需求，报OutOfMemoryError.

### 2.5.5 运行时常量池
运行时常量池是每个类或每个接口运行时的运行时代表，位于class文件的constant_pool表中。它包含多种常量，包含编译时确定的数字常量和运行时确定的方法和字段引用。运行时常量池和传统语言的符号表相似，当时包含的范围更多

每个运行时常量池在jvm的方法区中分配。运行时常量池在**类或者接口被创建时**创建

异常如下：
当创建类或者接口时，如果常量池的大小超过方法区的可用内存，则报OutOfMemoryError.

### 2.5.6 本地方法栈（Native Method Stacks）
java可能会调用其他语言编写的方法，称为本地方法，jvm使用本地栈来支持本地方法调用。本机方法栈也可以用于 Java 虚拟机指令集的解释器的实现，例如 C 语言。Java 虚拟机实现不能加载本机方法，而且不依赖于常规栈，因此不需要提供本机方法栈。如果提供了本机方法堆栈，则通常在每个线程被创建的时候

本规范允许本机方法堆栈具有固定的大小，或者根据计算的需要动态扩展和收缩。如果本机方法堆栈的大小是固定的，则在创建该堆栈时可以独立地选择每个本机方法堆栈的大小。

Java 虚拟机实现可以为程序员或用户提供对本机方法堆栈初始大小的控制，以及在本机方法堆栈大小不同的情况下，对最大和最小方法堆栈大小的控制。

异常如下：
- 如果线程中的计算需要比允许的更大的本机方法堆栈，Java 虚拟机将抛出 StackOverflow 错误。
- 如果本机方法堆栈可以动态扩展，并尝试本机方法堆栈扩展，但可用内存不足，或者如果可用内存不足，以创建新线程的初始本机方法堆栈，Java 虚拟机会抛出 OutOfMemory 错误。


## 2.6 帧
帧用于存储数据和部分结果，以及执行动态链接、方法的返回值和分发异常。每次调用方法时都会创建一个新的帧。帧在其方法调用完成时被销毁，无论该完成是正常的还是突然的(它抛出未捕获的异常)。帧是从创建框架的线程的 Java 虚拟机堆栈(2.5.2)中分配的。每个帧都有自己的局部变量数组(2.6.1)、自己的操作数堆栈(2.6.2)和对当前方法类的运行时常量池(2.5.5)的引用。

不同的实现可能包括额外的信息，例如调试信息

局部变量数组和操作数堆栈的大小在编译时确定，并与与帧关联的方法的代码一起提供。因此帧中的数据结构的大小只和特定的虚拟机实现有关。并且这些结构可以在方法被调用时分配。