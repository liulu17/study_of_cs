## 标识符
llvm有两种标识符：全局（函数，全局变量）和局部.全局（类型，寄存器名）用@前缀，局部用%前缀。特别的，有三种类型的标识符
1. 命名的值，例如%foo，@DivisionByZero
2. 匿名的值，例如%1，@2，%44
3. 常量

llvm要求使用%和@前缀的原因有两
1. 不会和llvm保留字冲突，llvm保留字不用%或者@
2. 编译器可以为匿名的标识符分配临时变量，而不会和符号表冲突

以下是三种示例代码，将整数变量 %x 乘以 8
简单方式
```llvm
%result = mul i32 %X, 8
```

```llvm
%result = shl i32 %X, 3
```
硬核方式
```llvm
%0 = add i32 %X, %X           ; yields i32:%0
%1 = add i32 %0, %0           ; yields i32:%1
%result = add i32 %1, %1
```
最后一种方式阐明了llvm几个重要的词法特征
1. 评论使用;符号
2. 当计算的结果没赋予给一个命名的变量，则会创建一个匿名的变量
3. 匿名变量在数字上是连续的，从0开始。注意基本块和匿名函数参数包块在内。例如，如果进入基本块没有赋予一个名称，所有函数参数都命名的，就会从0开始
   
## 模块结构
LLVM程序由多个模块组成，每个模块是输入程序的转换单元。每个模块包含函数，全局变量，符号表条目。模块可以使用LLVM链接器链接，链接器合并函数，全局变量，符号表，解析前向声明，这是一个"Hello world"模块的示例
```llvm
; Declare the string constant as a global constant.
@.str = private unnamed_addr constant [13 x i8] c"hello world\0A\00"

; External declaration of the puts function
declare i32 @puts(ptr nocapture) nounwind

; Definition of main function
define i32 @main() {
  ; Call puts function to write out the string to stdout.
  call i32 @puts(ptr @.str)
  ret i32 0
}

; Named metadata
!0 = !{i32 42, null, !"string"}
!foo = !{!0}
```

该模块由一个全局变量@.str、全局函数@puts、全局函数@main组成。和命名的元数据foo组成
通常，全局变量和函数都是由一个指针表示，这个例子中是一个指向字符数组的指针和一个函数指针。这些全局变量有如下**链接类型**


## 链接类型
所有全局变量和函数有如下链接类型
- privete
  只能由当前模块使用
- internal
  和private差不多。只不过呈现为一个本地符号。对应了C中的static
- available_externally

。。。。。
- external_weak
  这个语法是ELF目标文件模块中的，这个符号直到链接前是弱符号。如果没有被链接，符号成为null而不是一个未定义的引用
- external
  如果上面的链接属性都没被使用，则默认为external。这个属性使得该变量全局可见。意味着它参与链接，且可以被用来解析外部符号引用

**全局函数或者变量的声明必须是external或者external_weak**

## 调用约束
LLVM函数，call指令、invokes都有一个可选的调用约束。调用方和被调用方都必须遵循该约束，否则程序UB，LLVM支持一下调用约束
- "ccc" -c调用约束(默认)
  这个约束支持可变参数的函数调用，并且函数声明和定义不一致是可以接受的
- "fastcc" -快速调用约定 
  试图使用快速函数调用，例如使用寄存器存储。这个约束不支持可变参数的函数调用，并且函数声明和定义必须一致。约束允许目使用任何技巧对于特定的目标产生快速代码，而不用和特定的ABI一致。
- "coldcc" - 冷酷的调用约束
- "cc 10" - 特定于haskell
- "cc 11" - 特定于高性能erlang
- "webkit_jscc" -特定于Webkit javascript
- "anyregcc" -代码补丁的动态调用约束
- "preserve_mostcc" -
  此调用约定试图使调用方中的代码尽可能不受干扰。这个约定在传递参数和返回值的方式上与 C 调用约定的行为相同，但是它使用了一组不同的调用方/被调用方保存的寄存器。这减轻了在调用方中调用之前和之后保存和恢复一个大寄存器集的负担。如果参数是在被调用方保存的寄存器中传递的，那么它们将由被调用方在整个调用过程中保留。这不适用于被调用方保存的寄存器中返回值。
- "cxx_fast_tlscc" 
- "tailcc" -尾部调用约定
  这个调用约定确保在尾部位置的调用总是被尾部调用优化。这个调用约定等效于 fastcc，除了一个额外的保证，即只要有可能就会生成尾调用。只有在使用这个、 fastcc、 GHC 或 HiPE 约定时，才能优化尾调用。此调用约定不支持 varargs，并要求所有调用的原型与函数定义的原型完全匹配。
- "swiftcc" -特定于swift的约定
- "swifttailcc" -特定于swift的约定
- "cfguard_checkcc" 
- "cc <n>" -数字化的约束
  任何调用约定都可以通过数字指定，从而允许使用特定于目标的调用约定。特定于目标的调用约定从64开始。

可以根据需要添加/定义更多的调用约定，以支持 Pascal 约定或任何其他众所周知的独立于目标的约定。

## 可见性方式
所有全局变量和函数有如下可见性
- "default" -默认方式
  对于使用 ELF 对象文件格式的目标，默认可见性意味着声明对其他模块是可见的，并且在共享库中，意味着可以重写声明的实体。在 Darwin 上，默认可见性意味着声明对其他模块是可见的。在 XCOFF，默认可见性意味着不会设置显式可见性位，符号是否对其他模块可见(即“导出”)主要取决于提供给链接器的导出列表。默认可见性对应于语言中的“外部链接”。
- "hidden" -隐藏方式
  具有隐藏可见性的对象的两个声明如果位于同一个共享对象中，则引用同一个对象。通常，隐藏可见性表明该符号不会被放置到动态符号表中，因此没有其他模块(可执行或共享库)可以直接引用它。
- "protected" -保护风格
  在 ELF 上，受保护的可见性指示符号将放置在动态符号表中，但是定义模块中的引用将绑定到本地符号。也就是说，该符号不能被另一个模块重写

## DLL 存储类型
所有全局变量和函数有如下DLL 存储类型
- dllimport
- dllexport
  具有internal或者private链接性的符号不能有DLL 存储类型

## 线程局部存储模型
变量可以定义为 thread _ local，这意味着它不会被线程共享(每个线程将有一个独立的变量副本)。并非所有目标都支持线程局部变量。可选地，可以指定 TLS 模型:
- localdynamic
  只在当前共享库中使用的变量
- initialexec
  不会被动态加载的变量
- localexec
  可执行文件中定义并使用的变量

如果没有显示定义模型，使用"通用动态"模型
这些模型对应于 ELF TLS 模型; 有关在何种情况下可以使用不同模型的更多信息，请参见针对线程本地存储的 ELF 处理。如果指定的模型不受支持，或者可以做出更好的模型选择，目标可以选择不同的 TLS 模型。
模型也可以在别名中指定，但它只管理如何访问别名。它在别名中不会有任何作用。
对于不支持 ELF TLS 模型的连接器的平台，可以使用-feumated-TLS 标志生成与 GCC 兼容的仿真 TLS 码

## 运行时抢占
全局变量、函数和别名可能有一个可选的运行时抢占说明符。如果没有显式地给出抢占说明符，则假定符号为 dso_preemptable。
- dso_preemptable
指示在运行时可以用来自链接单元外部的符号替换函数或变量。
- dso_local
编译器可能假设标记为 dso_local 的函数或变量将解析为同一链接单元内的符号。即使定义不在此编译单元中，也会生成直接访问。

## 结构类型
LLVM同时允许标识化类型，或者结构类型的字面量。结构类型的字面量是结构上唯一的，但是标识化类型从不是唯一的。opaque结构化的类型可以用来前向申明类型
标识化的结构示例
```
%mytype = type {%mytype*,i32}
```
在LLVM3.0版本中，标识化的结构也是唯一的，目前，只有结构类型的字面量是唯一的

## 非整数指针类型
注意：非整数指针类型还在进展中，当前只是实验性的
LLVM IR 允许前端通过datalayout string将特定地址空间中的指针表示为“非整数”。非整数指针类型表示不指定位大小表示形式的指针; 也就是说，整数表示形式可能与目标相关或不稳定(不以固定整数支持)。
Inttoptr 和 ptrtoint 指令与整数(即普通)指针具有相同的语义，因为它们将整数与相应的指针类型进行转换，但是还有其他的含义需要注意。由于非整数指针的位表示可能不稳定，同一操作数的两个相同强制转换可能返回相同的值，也可能不返回相同的值。换句话说，向非整数类型转换或从非整数类型转换取决于环境状态以实现定义的方式。
如果前端希望在强制转换后观察特定的值，则生成的 IR 必须以实现定义的方式与底层环境保护。(实际上，这种操作往往需要非线性例程。)
从优化器的角度来看，非整型类型的 inttoptr 和 ptrtoint 类似于整型类型的 inttoptr 和 ptrtoint，但有一个关键的例外: 优化器通常不会插入这种强制转换的新的动态发生。如果插入新的强制转换，优化器需要确保 a)所有可能的值都是有效的，或 b)插入适当的隔离。由于适当的隔离是实现定义的，因此优化器不能执行后者。前者具有挑战性，因为许多常见的预期属性(如 ptrtoint (v)-ptrtoint (v) = = 0)不适用于非整数类型

## 全局变量
全局变量定义一块编译时分配的内存；全局变量必须在定义时初始化；全局变量在其他转换单元可以被声明，但是不用初始化。
全局变量可选的指定的链接类型

全局变量定义和声明可以有可选的显式节，可选的显式的对齐方式。如果变量声明的显式节信息和对齐信息与定义之间不匹配，则UB
一个变量可以被定义为一个全局常量，这表明变量的内容永远不会被修改(允许更好的优化，允许全局数据被放置在可执行文件的只读部分，等等)。注意，需要运行时初始化的变量不能标记为常量，因为该变量存储在一个存储区中。

LLVM 显式地允许将全局变量的声明标记为常量，即使全局变量的最终定义不是常量。这个功能可以用来稍微优化程序，但是需要语言定义来保证基于“常量”的优化对于不包含定义的翻译单元是有效的。

作为 SSA 值，全局变量定义范围内的指针值(即它们支配程序中的所有基本块)。全局变量总是定义一个指向其“内容”类型的指针，因为它们描述内存的一个区域，并且 LLVM 中的所有内存对象都是通过指针访问的。
全局变量可以用 unname_addr 标记，表示地址不重要，只有内容重要。如果标记为这样的常量具有相同的初始值设定项，则它们可以与其他常量合并。请注意，具有有效地址的常量可以与unname_addr 常量合并，其结果是具有有效地址的常量。

如果给定 local_unname_addr 属性，则已知该地址在模块中不重要。

可以将全局变量声明为驻留在特定于目标的编号地址空间中。对于支持它们的目标，地址空间可能会影响执行优化的方式和/或使用哪些目标指令来访问变量。默认地址空间为零。地址空间限定符必须位于任何其他属性之前。

LLVM 允许为全局变量指定一个显式节。如果目标支持它，它将向指定的节发出全局值。此外，如果目标具有必要的支持，则可以将全局放置在一个 comdat 中。

外部声明可以具有指定的显式节。在 LLVM IR，利用这些资料的目标会保留部分资料。将节信息附加到外部声明是断言其定义位于指定的节中。如果定义位于不同的部分，则行为是未定义的。

默认情况下，全局初始化器通过假设在模块中定义的全局变量不会在全局初始化器启动之前从它们的初始值进行修改来进行优化。即使对于可能从模块外部访问的变量也是如此，包括那些具有外部链接或出现在@llvm 中的变量。使用或 dllexported 的变量。这个假设可以通过使用外部初始化标记变量来抑制。

可以为全局指定显式对齐，全局对齐的幂必须为2。如果不存在，或者如果对齐设置为零，则目标将全局对齐设置为它感觉方便的任何值。如果指定了显式对齐方式，则强制全局变量对齐方式必须与该对齐方式完全一致。如果全局变量有一个分配的节，则不允许目标和优化器过度对齐全局变量。在这种情况下，额外的对齐是可以观察到的: 例如，代码可以假设全局变量在它们的部分中密集排列，并尝试将它们作为数组进行迭代，对齐填充会破坏这种迭代。最大对齐方式为1 < < 32。

对于全局变量声明，以及可能在链接时被替换的定义(linkonce, weak, extern_weak and common linkage types) ，LLVM 不会假设变量的分配大小，除非它们可能不会重叠。全局变量声明或可替换定义的对齐方式不得大于它所解析的定义的对齐方式。

全局变量还可以有一个 DLL 存储类、一个可选的运行时抢占说明符、一个可选的全局属性和一个可选的附加元数据列表。

变量和别名可以具有线程本地存储模型

可伸缩向量不能是全局变量或数组成员，因为它们在编译时的大小是未知的。在结构中允许使用它们来方便内部函数返回多个值。包含可伸缩向量的结构不能在加载、存储、分配或 GEP 中使用。

语法如下：
```llvm
@<GlobalVarName> = [Linkage] [PreemptionSpecifier] [Visibility]
                   [DLLStorageClass] [ThreadLocal]
                   [(unnamed_addr|local_unnamed_addr)] [AddrSpace]
                   [ExternallyInitialized]
                   <global | constant> <Type> [<InitializerConstant>]
                   [, section "name"] [, partition "name"]
                   [, comdat [($name)]] [, align <Alignment>]
                   [, no_sanitize_address] [, no_sanitize_hwaddress]
                   [, sanitize_address_dyninit] [, sanitize_memtag]
                   (, !name !N)*
```
例如,下面定义了一个全局变量，变量定义在数字化的地址空间中，有一个初始化器，节，对齐
```llvm
@G = addrspace(5) constant float 1.0, section "foo", align 4
```

下面只是定义了一个全局变量
```llvm
@G = external global i32
```
下面定义了一个线程局部全局变量，TLS模型为initialexec
```llvm
@G = thread_local(initialexec) global i32 0, align 4
```

## 函数
LLVM 函数定义包括define关键字、可选的链接类型、可选的运行时抢占指定符、可选的可见性样式、可选的 DLL 存储类、可选的调用约定、可选的 unname_addr 属性、返回类型、返回类型的可选参数属性、函数名称,参数列表(可能为空)、可选函数属性、可选地址空间、可选部分、可选分区、可选对齐、可选指数、可选垃圾收集器名称、可选前缀、可选序言、可选个性、可选附加元数据列表、开头花括号、基本块列表和结尾花括号。
语法:
```llvm
define [linkage] [PreemptionSpecifier] [visibility] [DLLStorageClass]
       [cconv] [ret attrs]
       <ResultType> @<FunctionName> ([argument list])
       [(unnamed_addr|local_unnamed_addr)] [AddrSpace] [fn Attrs]
       [section "name"] [partition "name"] [comdat [($name)]] [align N]
       [gc] [prefix Constant] [prologue Constant] [personality Constant]
       (!name !N)* { ... }
```
参数列表使用逗号分隔，每个参数形式如下:
```llvm
<type> [parameter Attrs] [name]
```

LLVM声明包括declare关键字，可选的链接类型，可选的可见性样式，可选的 DLL 存储类，可选的调用约定，可选的 unname_addr 属性，可选地址空间，返回类型，返回类型的可选参数属性，函数名，可能得参数空列表，可选的对齐，可选的垃圾回收名字，可选的前缀
语法：
```llvm
declare [linkage] [visibility] [DLLStorageClass]
        [cconv] [ret attrs]
        <ResultType> @<FunctionName> ([argument list])
        [(unnamed_addr|local_unnamed_addr)] [align N] [gc]
        [prefix Constant] [prologue Constant]
```

函数定义包含一个基本块列表，形成函数的 CFG (控制流程图)。每个基本块可以选择从一个标签开始(给基本块一个符号表条目) ，包含一个指令列表，并以一个结束符指令(如分支或函数返回)结束。如果未提供显式标签名称，则使用与未命名临时项相同的计数器中的下一个值为块分配隐式编号标签(参见上文)。例如，如果一个函数条目块没有显式的标签，它将被分配标签“% 0”，那么该块中第一个未命名的临时标签将是“% 1”，等等。如果显式指定了数值标签，则它必须与将隐式使用的数值标签匹配。

函数的第一个基本块在两个方面是特殊的: 它在函数的入口处立即执行，不允许有前面的基本块(即不能有任何分支到函数的入口块)。因为该块不能有任何前置，所以它也不能有任何 PHI 节点。

LLVM 允许为函数指定显式节。如果目标支持它，它将向指定的节发出函数。此外，该函数可以放置在 COMDAT 中。

可以为函数指定显式对齐方式。如果不存在，或者如果对齐设置为零，那么函数的对齐将由目标设置为它感觉方便的任何值。如果指定了显式对齐方式，则函数必须至少具有对应的对齐方式。所有对齐必须是2的幂。

如果给定了 unname_addr 属性，则已知地址不重要，并且可以合并两个相同的函数。

如果给定 local_unname_addr 属性，则已知该地址在模块中不重要。

如果没有给出明确的地址空间，那么它将默认为 datalayout 字符串中的程序地址空间。


## 别名
别名与函数或变量不同，它不创建任何新数据。它们只是现有位置的新符号和元数据。

别名具有一个名称和一个别名，该别名或者是一个全局值，或者是一个常量表达式。

别名可以具有可选的链接类型、可选的运行时抢占说明符、可选的可见性样式、可选的 DLL 存储类和可选的 tls 模型。

句法:
```llvm
@<Name> = [Linkage] [PreemptionSpecifier] [Visibility] [DLLStorageClass] [ThreadLocal] [(unnamed_addr|local_unnamed_addr)] alias <AliaseeTy>, <AliaseeTy>* @<Aliasee>
          [, partition "name"]
```

链接属性必须是private, internal, linkonce, weak, linkonce_odr, weak_odr, external, available_externally.之一。注意，有些系统链接器可能无法正确处理删除别名的弱符号。


不是 unname_addr 的别名保证具有与别名表达式相同的地址。unname_addr 只能保证指向相同的内容。

如果给定 local_unname_addr 属性，则已知该地址在模块中不重要。
由于别名只是第二个名称，因此应用了一些限制，其中一些限制只能在生成目标文件时检查:
- 定义别名的表达式在汇编时必须是可计算的。因为它只是一个名称，所以不能使用重新定位。
- 表达式中的任何别名都不能为weak，因为中间别名被重写的可能性，所以不能在对象文件中表示。
- 如果别名具有available_externally的链接属性，那么别名必须是available_externally全局值; 否则别名可以是表达式，但是表达式中的不能声明全局值，因为这需要重新定位，而这是不可能的。
- 如果在链接时或运行时别名或被别名的名称可能被模块外的符号替换，则任何优化都不能用别名替换别名，因为行为可能不同。别名可以用作名称，保证指向当前模块中的内容。


## IFuncs
IFuncs 与别名一样，不创建任何新数据或 func。它们只是动态链接器在运行时通过调用解析器函数解析的新符号。

IFuncs 有一个名称和一个解析器，该解析器是由动态链接器调用的函数，它返回与该名称关联的另一个函数的地址。

IFunc 可能有一个可选的链接类型和一个可选的可见性样式。
句法:
```llvm
@<Name> = [Linkage] [PreemptionSpecifier] [Visibility] ifunc <IFuncTy>, <ResolverTy>* @<Resolver>
          [, partition "name"]
```

## Comdats
COMDAT IR 提供对目标文件 COMDAT/节组功能的访问，这些功能表示相互关联的节。

Comdats 有一个表示 COMDAT 键的名称和一个选择类型，用于提供关于链接器如何在两个不同的对象文件中使用相同的键删除 Comdats 的输入。指针必须作为一个单位包括或省略。允许丢弃整个 Comdat，但不允许丢弃子集。

一个全局对象最多只能是一个坐标的成员。别名放置在其别名计算到的 COMDAT 中(如果有的话)。
语法：

```llvm
$<Name> = comdat SelectionKind
```
//todo

## 命名的元数据
命名的元数据是元数据的集合，元数据节点（不是元数据字符串）是命名的元数据唯一有效的操作数
1. 命名的元数据由字符串表示，该字符串有个元数据前缀。元数据名称不能有引号。"\xx"类型的逃逸符号是有效的
   
语法：
```llvm
; Some unnamed metadata nodes, which are referenced by the named metadata.
!0 = !{!"zero"}
!1 = !{!"one"}
!2 = !{!"two"}
; A named metadata.
!name = !{!0, !1, !2}
```

## 参数属性
函数返回值和参数都有一系列相关的属性。参数属性用来与额外的返回值或参数信息通信。
参数属性跟随在参数类型后面，是关键字。
示例：
```llvm
declare i32 @printf(ptr noalias nocapture, ...)
declare i32 @atoi(i8 zeroext)
declare signext i8 @returns_signed_char()
```

注意任何返回值的属性都跟随在函数参数列表的最后面
目前支持一下参数属性：
- [] todo

## 垃圾回收策略名
每个函数能指定垃圾回收策略名
```llvm
define void @f() gc "name" { ... }
```
- [] todo

## 前缀数据
前缀数据是与函数关联的数据，代码生成器将在函数的入口点之前立即发出这些数据。这个特性的目的是允许前端将特定语言的运行时元数据与特定函数关联起来，并通过函数指针提供，同时仍然允许调用函数指针。

为了访问给定函数的数据，程序可以将函数指针转换为指向常量类型和解引用索引 -1的指针。这意味着 IR 符号指向的位置刚刚超过前缀数据的末尾。例如，以一个带有单个i32前缀数据的函数为例,
```llvm
define void @f() prefix i32 123 { ... }
```
前缀数据可以如下方式引用
```llvm
%a = getelementptr inbounds i32, ptr @f, i32 -1
%b = load i32, ptr %a
```

前缀数据布局就像它是一个某个类型的全局变量的初始化器。函数的放置方式使得前缀数据的开头对齐。这意味着如果前缀数据的大小不是对齐大小的倍数，则函数的入口点将不会对齐。如果需要对函数的入口点进行对齐，则必须向前缀数据添加填充。

函数可以有前缀数据，但是没有主体。这个链接的语义类似于可用的外部链接，因为数据可以由优化器使用，但是不会在对象目标中发出。


## 序言数据
序言数据允许任意的代码可以被插入到函数体的前面，这可用于启用函数热修补和检测。

为了维护普通函数调用的语义，序言数据必须具有特定的格式。具体来说，它必须以一系列字节开始，这些字节解码为一系列机器指令，对模块的目标有效，这些机器指令将控制转移到序言数据之后的点，而不执行任何其他可见的操作。这允许内联函数和其他passes对函数定义语义的推理，而不需要推理序言数据。显然，这使得序言数据的格式高度依赖于目标。
- [] not understand

一个简单的列子，x86架构的序言数据i8 144 对应个nop指令
```llvm
define void @f() prologue i8 144 { ... }
```
一般来说，序言数据可以通过编码跳过元数据的相对分支指令来形成，就像在 x86 _ 64体系结构的有效序言数据示例中一样，其中前两个字节进行了编码 jmp .+10
```llvm
%0 = type <{ i8, i8, ptr }>

define void @f() prologue %0 <{ i8 235, i8 8, ptr @md}> { ... }
```

函数可能有序言数据，但没有主体。这个链接的语义类似于available_externally链接属性，因为数据可以由优化器使用，但是不会在目标文件中发出。


## Personality 函数
函数可以通过Personality 函数属性指定异常处理

## 属性组
属性组是由 IR 中的对象引用的属性组。它们对于保持.Ll 文件可读很重要，因为许多函数将使用相同的属性集。

属性组是模块级对象。要使用属性组，对象引用属性组的 ID (例如 # 37)。一个对象可以引用多个属性组。在这种情况下，将合并来自不同组的属性。

下面是一个函数的属性组示例，该函数应该始终内联，堆栈对齐方式为4，并且不应该使用 SSE 指令
```llvm
; Target-independent attributes:
attributes #0 = { alwaysinline alignstack=4 }

; Target-dependent attributes:
attributes #1 = { "no-sse" }

; Function @f has attributes: alwaysinline, alignstack=4, and "no-sse".
define void @f() #0 #1 { ... }
```

## 函数属性
函数属性设置为了传递有关函数的附加信息。函数属性被认为是**函数的一部分**，而不是**函数类型**的一部分，因此具有不同函数属性的函数可以具有相同的函数类型。
函数属性是遵循指定类型的简单关键字。如果需要多个属性，则它们是空间分隔的。例如:
```llvm
define void @f() noinline { ... }
define void @f() alwaysinline { ... }
define void @f() alwaysinline optsize { ... }
define void @f() optsize { ... }
```
具体属性如下
- [] todolist

# 调用站点属性
除了函数属性之外，还支持以下调用站点属性:
- [] todolist

## 全局属性
可以通过设置属性来传递有关全局变量的其他信息。与函数属性不同，全局变量上的属性分组为单个属性组。
- no_sanitize_address
- no_sanitize_hwaddress
- sanitize_memtag
- sanitize_address_dyninit

## 参数数捆绑
操作数捆绑是标记的 SSA 值集，可以与某些 LLVM 指令相关联(call s 和 invoke s)。在某种程度上，它们类似于元数据，但是删除它们是不正确的，并且会改变程序语义
语法：
```llvm
operand bundle set ::= '[' operand bundle (, operand bundle )* ']'
operand bundle ::= tag '(' [ bundle operand ] (, bundle operand )* ')'
bundle operand ::= SSA value
tag ::= string constant
```
- [] todo

## 模块级内联汇编
模块可以包含"模块级别的内联汇编"块，它对应于 GCC 的"文件范围内联汇编"块。这些块在内部由 LLVM 连接，并被视为一个单独的单元，但是可以在 .ll 文件中分离。语法非常简单:
```llvm
module asm "inline asm code goes here"
module asm "more can go here"
```
字符串可以通过转义非打印字符来包含任何字符。使用的转义序列只是"\ xx"，其中"xx"是该数字的两位十六进制代码。

注意，汇编字符串必须可由 LLVM 的集成汇编程序解析(除非禁用它) ，即使在发出.s文件

## 数据布局
模块可以指定target特定的数据布局，表名数据在内存中的布局。语法如下：
```llvm
target datalayout = "layout specification"
```
数据布局规范包含一系列规范，由'-'符号分割，每个规范以字母开头，字母之后可能包含其他信息，以定义数据布局的某些方面。接受的规格如下:
- E 大端形式
- e 小端
- S<size> 指定以位为单位的堆栈的自然对齐方式。为了避免动态堆栈重新排列，堆栈变量的排列提升仅限于自然堆栈排列。堆栈对齐方式必须是8位的倍数。如果省略，自然堆栈对齐默认为“未指定”，这不会阻止任何对齐提升。
- P\<address space> 指定程序内存的地址空间。哈佛体系结构可以使用它来指定 LLVM 应该将函数之类的东西放入什么空间。如果省略，程序内存空间默认为默认地址空间为0，这相当于一个冯·诺伊曼结构，代码和数据位于同一空间。
- G\<address spqce> 指定全局变量的地址空间。如果省略，全局变量内存空间默认为默认地址空间为0。注意：没有地址空间的变量声明总是在地址空间0中创建，这个属性只影响在创建没有额外上下文信息的全局变量时使用的默认值(例如在 LLVM 传递中)。
- A\<address space> 指定通过alloca创建的对象的内存布局。默认地址空间为0。
- p[n]:\<size>:\<abi>[:\<pref>][:\<idx>] 指定指针大小，abi，pref。pref是可选的，默认为abi。idx为索引大小，用来做地址计算。如果未指定，默认为指针大小。所有的地址大小都是以位为单位。n为地址空间，是可选的，未指定的话，为默认的地址空间0。n必须是[1,2^23]之间
- i\<size>:\<abi>[:\<pref>] 指定整数类型的对齐属性。size以位为单位的整数大小。size必须是[1,2^23]之间。pref是可选的，默认为abi
- v\<size>:\<abi>[:\<pref>] 指定vector类型的对齐属性。size以位为单位的整数大小。size必须是[1,2^23]之间。pref是可选的，默认为abi
- f\<size>:\<abi>[:\<pref>] 指定浮点类型的对齐属性。size以位为单位的整数大小。只有target支持的size才行。32（float）和64（double)被所有平台支持，80或者128在某些平台支持。 size必须是[1,2^23]之间。pref是可选的，默认为abi
- a:\<abi>[:\<pref>] 聚合类型的对象的对齐属性。pref是可选的，默认为abi
- F\<type>\<abi> 函数指针的对齐属性。type有如下可选项：
  1. i:函数指针和函数的对齐不相关，是abi的倍数
  2. h:函数指针对齐是函数的对齐的倍数，是abi的倍数
- m:\<mangling> 如果指定了，则LLVM的名称会被修饰。带有修饰逃逸字符\01前缀的符号会直接传递给汇编器。可选的重整选项为：
  1. e:elf修饰:私有符号得到一个.L前缀
  2. l:GOFF修饰:私有符号得到@前缀
  3. m:Mips修饰:私有符号得到$前缀
  4. o:Mach-O 修饰：私有符号使用L前缀，其他符号使用_前缀
  5. x:Windows x86 COFF 修饰：私有符号获得通常的前缀。普通 C 符号获得一个 _ 前缀。__stdcall,__fast_call,__vectorcall 函数有通常的修饰，添加@N，N是参数字节数.c++ 以开头的符号不会被修饰
  6. w：Windows COFF 修饰：和相似，除了正常的C符号不会获得_前缀
  7. a：COFF修饰：私有变量获得L..前缀
- n\<size1>:\<size2>:\<size3>... 对于指定的平台，指定原生的整数宽度。
- ni:\<address space0>:\<address space1>:\<address space2>... 指定地址空间为非整数指针类型 s 的指针类型。不能将0地址空间指定为非整数。

在构造给定目标的数据布局时，LLVM 首先使用默认的规范集，然后(可能)被 datalayout 关键字中的规范覆盖。下面列出了默认的规范:
- e-小端
- p:64:64:64-64位指针与64位对齐。
- p[n]:64:64:64-假定其他地址空间与默认地址空间相同。
- S0-未指定自然堆栈对齐方式
- i1:8:8-i1是8位(字节)对齐的
- i8:8:8-i8是8位(字节)对齐的
- i16:16:16-i16是16位对齐的
- i32:32:32-i32是32位对齐的
- i64:32:64-i64的ABI对齐方式为32位，但首选的对齐方式为64位
- f16:16:16-half是16位对齐的
- f32:32:32-float是32位对齐的
- f64:64:64-double是64位对齐的
- f128:128:128-quad是128位对齐的
- v64:64:64-64位向量是64位对齐的
- v128:128:128-128位向量是128位对齐的
- a:0:64-聚合是64位对齐的

当 LLVM 确定给定类型的对齐方式时，它使用以下规则:
1. 如果所寻求的类型与其中一个规范完全匹配，则使用该规范。
2. 如果未找到匹配项，且所寻找的类型为整数类型，则使用大于所寻找类型的位宽的最小整数类型。如果所有规范都不大于位宽，则使用最大整数类型。例如，给定上面的默认规范，i7类型将使用 i8(下一个最大值)的对齐方式，而 i65和 i256都将使用 i64(指定的最大值)的对齐方式。

函数的数据布局字符串可能与您期望的不同。值得注意的是，这并不是代码生成器应该使用什么对齐方式的前端规范。

相反，如果指定了，则需要目标数据布局来匹配最终代码生成器所期望的结果。中级优化器使用此字符串来改进代码，并且只有当它与最终代码生成器所使用的内容匹配时才能正常工作。没有任何方法可以生成不将这个特定于目标的细节嵌入到 IR 中的 IR。如果你没有指定字符串，默认的规范将被用来生成一个数据布局，优化阶段将相应地操作，并且相对于这些默认的规范，将目标特异性引入到 IR 中。

## 目标三元祖
模块可以指定描述目标主机的目标三重字符串。目标三元组的语法很简单:
```llvm
target triple = "x86_64-apple-macosx10.7.0"
```
'-'分割的字符串格式如下：
```llvm
ARCHITECTURE-VENDOR-OPERATING_SYSTEM
ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT
```
此信息被传递到后端，以便它为适当的体系结构生成代码。可以在命令行上使用-mthree 命令行选项覆盖这一点。

## 对象生命周期
内存对象(或简称对象)是由内存分配(如分配、堆分配调用和全局变量定义)保留的内存空间区域。一旦分配，存储在区域中的字节只能通过基于分配值的指针读取或写入。如果一个不基于对象的指针尝试读取或写入对象，那么它就是未定义行为。

内存对象的生存期是决定其可访问性的属性。除非另有说明，否则内存对象在其分配之后是活跃的，在其释放之后是消逝的。访问一个不存在的内存对象是未定义行为。但是不对其解引用的操作，如 getelementptr、 ptrtoint 和 icmp，会返回一个有效的结果。这解释了这些指令在影响对象生命周期的操作中的代码运动。可以使用 llvm.lifetime.start 和 llvm.lifetime.end 内部函数调用显式指定堆栈对象的生命周期。

## 指针别名规则
任何内存访问都必须通过与内存访问的地址范围相关联的指针值来完成，否则行为是未定义的。根据以下规则，指针值与地址范围相关联：
- 指针值与它所基于的任何值关联的地址相关联。
- 全局变量的地址与变量存储的地址范围相关联。
- 分配指令的结果值与所分配存储器的地址范围相关联。
- 默认地址空间中的空指针与没有地址关联。
- 任何地址空间中的 undef 值都与没有地址关联
  
基于其他指针值的指针值基于以下规则：
- 从getelementptr操作形成的指针的类型是getelementptr操作的指针类型
- 一个向量 getelementptr 操作的结果指针基于 getelementptr的向量的指针类型
- bitcast的结果值基于bitcast的操作数
- 由 inttoptr 形成的指针值基于(直接或间接)对指针值的计算有贡献的所有指针值。
- 规则是传递的

请注意，这个“基于”的定义有意与 C99中的“基于”定义相似，尽管它稍弱一些。

LLVM IR 不将类型与内存关联。加载的结果类型仅指示要加载的内存的大小和对齐方式，以及对值的解释。类似地，store的第一个操作数类型仅指示存储区的大小和对齐方式。
因此，基于类型的别名分析，又名 TBAA，又名-fstric- 别名，不适用于一般的未修饰 LLVM IR。元数据可用于编码附加信息，专门的优化通过这些信息可用于实现基于类型的别名分析。

## 指针捕获
给定一个函数调用和一个作为参数传递或存储在调用之前的内存中的指针，如果指针的任何部分在调用中被拷贝，且在调用之后仍然存在，那么调用就会捕获该指针。确切地说，如果下列一个或多个条件符合，则捕获指针:
1. 调用存储指针的任何位，将信息传送到一个位置，并且在调用退出后，调用方可以从该位读取存储的位。
```llvm
@glb  = global ptr null
@glb2 = global ptr null
@glb3 = global ptr null
@glbi = global i32 0

define ptr @f(ptr %a, ptr %b, ptr %c, ptr %d, ptr %e) {
  store ptr %a, ptr @glb ; %a is captured by this call

  store ptr %b,   ptr @glb2 ; %b isn't captured because the stored value is overwritten by the store below
  store ptr null, ptr @glb2

  store ptr %c,   ptr @glb3
  call void @g() ; If @g makes a copy of %c that outlives this call (@f), %c is captured
  store ptr null, ptr @glb3

  %i = ptrtoint ptr %d to i64
  %j = trunc i64 %i to i32
  store i32 %j, ptr @glbi ; %d is captured

  ret ptr %e ; %e is captured
}
```
2. 调用存储指针的任何位，将信息传送到一个位置，通过同步，另一个线程可以安全地从该位读取存储的位。
```llvm
@lock = global i1 true

define void @f(ptr %a) {
  store ptr %a, ptr* @glb
  store atomic i1 false, ptr @lock release ; %a is captured because another thread can safely read @glb
  store ptr null, ptr @glb
  ret void
}
```